{"version":3,"file":"static/js/5106.60b94d9d.chunk.js","mappings":"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","sources":["context/compilation/requests.ts","api/codeStorage.ts","api/webFileSystem.ts","infrastructure/loggers.tsx","api/parser.tsx","context/project/logModel.tsx","infrastructure/dateFunctions.ts","context/compilation/executionLogModel.ts","context/compilation/resultsModel.ts","context/compilation/specificationsLogModel.ts","context/compilation/worker.ts","context/compilation/runScenarios.ts","api/operationStorage.ts","api/indexedDb/indexedDBStore.ts","api/idbConfig.ts","context/project/nodeModel.ts","infrastructure/nothing.ts","context/compilation/response.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import {ParametersModel} from \"./resultsModel\";\n\nexport enum RequestType {\n  StartCompilation,\n  RunFunction\n}\n\nexport type StartCompilationRequest = {\n  readonly type: RequestType.StartCompilation;\n  readonly folder: string[];\n  readonly fileName: string;\n  readonly code: string;\n  readonly timestamp: string;\n}\n\nexport type RunFunctionRequest = {\n  readonly type: RequestType.RunFunction;\n  readonly folder: string[];\n  readonly fileName: string;\n  readonly functionName: string;\n  readonly parameters: ParametersModel;\n}\n\nexport type Request = StartCompilationRequest | RunFunctionRequest;\n","import {useMemo} from \"react\";\nimport {IndexedDBStore, windowIndexedDBStore, workerIndexedDBStore} from \"./indexedDb/indexedDBStore\";\nimport {idbConfig} from \"./idbConfig\";\n\ninterface FileCode {\n  id: string,\n  code: string\n}\n\nexport interface CodeFileStorage {\n  getCodeFile(identifier: string): Promise<string | null>;\n  storeCodeFile(identifier: string, code: string, override: boolean): Promise<boolean>;\n  clearCodeFiles(): Promise<any>;\n}\n\nfunction codeFileStorage(filesStore: IndexedDBStore<FileCode>): CodeFileStorage {\n\n  const {getByID, addIfNew, update, deleteAll} = filesStore;\n\n  function getCodeFile(identifier: string): Promise<string | null> {\n    return new Promise<string | null>((resolve, reject) =>\n      getByID(identifier)\n        .then(value => value ? resolve(value.code) : resolve(null))\n        .catch(reject));\n  }\n\n  function storeCodeFile(identifier: string, code: string, override: boolean): Promise<boolean> {\n    if (!override) {\n      return new Promise<boolean>((resolve, reject) => {\n        addIfNew({id: identifier, code: code}, identifier)\n          .then(id => resolve(id != null))\n          .catch(reject);\n      });\n    }\n\n    return new Promise<boolean>((resolve, reject) => {\n      update({id: identifier, code: code}, identifier)\n        .then(_ => resolve(true))\n        .catch(reject);\n    });\n  }\n\n  function clearCodeFiles(): Promise<any> {\n    return deleteAll();\n  }\n\n  return {\n    getCodeFile: getCodeFile,\n    storeCodeFile: storeCodeFile,\n    clearCodeFiles: clearCodeFiles\n  }\n}\n\nexport function useCodeFileStorage(): CodeFileStorage {\n  const store = useMemo(() => {\n    const storeFiles = windowIndexedDBStore<FileCode>(idbConfig, \"code-files\");\n    return codeFileStorage(storeFiles);\n  }, []);\n  return store;\n}\n\nexport function workerCodeFileStorage(): CodeFileStorage {\n  const storeFiles = workerIndexedDBStore<FileCode>(idbConfig, \"code-files\");\n  return codeFileStorage(storeFiles);\n}\n","import {IFileSystem} from \"lexy\";\nimport {CodeFileStorage, workerCodeFileStorage} from \"./codeStorage\";\n\nexport class WebFileSystem implements IFileSystem {\n\n  private readonly currentFolder: string[];\n  private readonly store: CodeFileStorage;\n\n  constructor(currentFolder: string[]) {\n    this.currentFolder = currentFolder;\n    this.store = workerCodeFileStorage();\n  }\n\n  async readAllLines(fileName: string): Promise<string[]> {\n    const fullFile = this.isPathRooted(fileName) ? fileName : this.getFullPath(fileName);\n    const parts = fullFile.split(\"/\");\n    this.removeFirst(parts);\n    const data = await this.store.getCodeFile(parts.join(\"|\"));\n    if (!data) {\n      throw new Error(\"Couldn't load: \" + fileName);\n    }\n    return data.split(\"\\n\");\n  }\n\n  getFileName(fullFileName: string): string {\n    return fullFileName;\n  }\n\n  getDirectoryName(parentFullFileName: string): string {\n    const parts = parentFullFileName.split(\"/\");\n    this.removeLast(parts);\n    return parts.length > 0 ? parts.join(\"/\") : \"\";\n  }\n\n  getFullPath(fileName: string): string {\n    if (this.isPathRooted(fileName)) return fileName;\n\n    const parts = fileName.split(\"/\");\n    const folder = [...this.currentFolder];\n    for (const part of parts) {\n      if (part === \"..\") {\n        this.removeLast(folder);\n      } else {\n        folder.push(part)\n      }\n    }\n    const fullPath = folder.join(\"/\");\n    return \"/\" + fullPath;\n  }\n\n  private removeLast(folder: string[]) {\n    folder.splice(folder.length - 1, 1);\n  }\n\n  private removeFirst(folder: string[]) {\n    folder.splice(0, 1);\n  }\n\n  combine(fullPath: string, fileName: string): string {\n    if (fullPath.length === 0) return fileName;\n    const parts = fullPath.split(\"/\");\n    if (parts[parts.length - 1].length === 0) this.removeLast(parts);\n\n    const fileParts = fileName.split(\"/\");\n\n    for (const part of fileParts) {\n      if (part === \"..\") {\n        this.removeLast(parts);\n      } else {\n        parts.push(part)\n      }\n    }\n    return parts.join(\"/\");\n  }\n\n  async fileExists(fileName: string): Promise<boolean> {\n    const parts = fileName.split(\"/\");\n    if (parts[0].length === 0) this.removeFirst(parts);\n    const data = await this.store.getCodeFile(parts.join('|'));\n    return !!data;\n  }\n\n  async directoryExists(absoluteFolder: string): Promise<boolean> {\n    throw new Error(\"Not implemented.\")\n  }\n\n  isPathRooted(folder: string): boolean {\n    return folder.startsWith(\"/\");\n  }\n\n  async getDirectoryFiles(folder: string, extension: Array<string>): Promise<string[]> {\n    return [];\n  }\n\n  async getDirectories(folder: string): Promise<string[]> {\n    return [];\n  }\n\n  logFolders(): string {\n    return \"\";\n  }\n}\n","import {ILogger, LogLevel} from \"lexy\";\n\nexport class DummyLogger implements ILogger {\n\n  isEnabled(level: LogLevel): boolean {\n    return false;\n  }\n\n  logDebug(message: string): void {\n  }\n\n  logError(message: string): void {\n  }\n\n  logInformation(message: string): void {\n  }\n}\n\nexport type MemoryLogEntry = {\n  message: string,\n  level: LogLevel,\n}\n\nexport class MemoryLogger implements ILogger {\n\n  private loggingValue: Array<MemoryLogEntry> = [];\n\n  public get logging(): ReadonlyArray<MemoryLogEntry> {\n    return this.loggingValue;\n  }\n\n  isEnabled(level: LogLevel): boolean {\n    return true;\n  }\n\n  logDebug(message: string): void {\n    this.loggingValue.push({message: message, level: LogLevel.Debug});\n  }\n\n  logError(message: string): void {\n    this.loggingValue.push({message: message, level: LogLevel.Error});\n  }\n\n  logInformation(message: string): void {\n    this.loggingValue.push({message: message, level: LogLevel.Information});\n  }\n}","import {createCompiler, createParser, IFileSystem, ILexyCompiler} from \"lexy\";\nimport {IParserLogger, LogEntry} from \"lexy/dist/parser/parserLogger\";\nimport {IComponentNode} from \"lexy/dist/language/componentNode\";\nimport {CompilerResult} from \"lexy/dist/generation/compilerResult\";\nimport {DummyLogger} from \"../infrastructure/loggers\";\nimport {ComponentNodeList} from \"lexy/dist/language/componentNodeList\";\nimport {Libraries} from \"lexy/dist/functionLibraries/libraries\";\nimport {milliseconds} from \"lexy/dist/runTime/libraries/dateLibrary\";\nimport {Dependencies} from \"lexy/dist/dependencyGraph/dependencies\";\n\nexport type ParseResult = {\n  logger: IParserLogger;\n  logging: Array<LogEntry>;\n  nodes: ComponentNodeList;\n  elapsed: number;\n  dependencies: Dependencies\n}\n\nconst baseLogger = new DummyLogger();\n\nexport async function parseLines(fileName: string, lines: string[], fileSystem: IFileSystem): Promise<ParseResult> {\n  const startTime = new Date();\n  const lexyParser = createParser(baseLogger, fileSystem, new Libraries([]));\n  const {componentNodes, logger, dependencies} = await lexyParser.parse(lines, fileName, {suppressException: true});\n  const elapsed = milliseconds(new Date(), startTime).toNumber();\n  return {logging: logger.entries, nodes: componentNodes, logger: logger, elapsed: elapsed, dependencies: dependencies}\n}\n\nexport async function parseCode(fileName: string, code: string, fileSystem: IFileSystem): Promise<ParseResult> {\n  const lines = code.split(\"\\n\");\n  return await parseLines(fileName, lines, fileSystem);\n}\n\nexport async function parseFile(fileName: string, fileSystem: IFileSystem): Promise<ParseResult> {\n  const startTime = new Date();\n  const lexyParser = createParser(baseLogger, fileSystem, new Libraries([]));\n  const {componentNodes, logger, dependencies} = await lexyParser.parseFile(fileName, {suppressException: true});\n  const elapsed = milliseconds(new Date(), startTime).toNumber();\n  return {logging: logger.entries, nodes: componentNodes, logger: logger, elapsed: elapsed, dependencies: dependencies}\n}\n\nexport function createLexyCompiler(): ILexyCompiler {\n  return createCompiler(baseLogger, baseLogger, new Libraries([]));\n}\n\nexport function compileNodes(nodes: readonly IComponentNode[]): CompilerResult {\n  const lexyCompiler = createLexyCompiler();\n  return lexyCompiler.compile(nodes);\n}\n","import {LogEntry} from \"lexy/dist/parser/parserLogger\";\n\nexport interface LogModel {\n  readonly fileName: string;\n  readonly lineNumber: number;\n  readonly characterNumber: number;\n  readonly sortIndex: string;\n  readonly isError: boolean;\n  readonly message: string;\n}\n\nexport function mapLogging(logging: LogEntry[]): LogModel[] {\n  return logging.map(mapLogEntry);\n}\n\nexport function mapLogEntry(entry: LogEntry): LogModel {\n  return {\n    fileName: entry.reference.file.fileName,\n    lineNumber: entry.reference.lineNumber,\n    characterNumber: entry.reference.characterNumber,\n    sortIndex: entry.sortIndex,\n    isError: entry.isError,\n    message: entry.message\n  };\n}\n","import Decimal from \"decimal.js\";\n\nfunction differenceInMilliseconds(laterDate: Date, earlierDate: Date): Decimal {\n  return Decimal(+laterDate - +earlierDate);\n}\n\nexport function milliseconds(end: Date, start: Date): Decimal {\n  return differenceInMilliseconds(end, start);\n}\n","import {LogVariables} from \"lexy/dist/runTime/executionContext\";\nimport {ExecutionLogEntry} from \"lexy/dist/runTime/executionLogEntry\";\nimport {Nothing} from \"../../infrastructure/nothing\";\n\nexport type LogVariableModel = Date | string | number | boolean | LogVariables;\n\nexport type LogVariablesModel = {\n  [key: string]: LogVariableModel;\n};\n\nexport interface ExecutionLogModel {\n  readonly message: string;\n  readonly readVariables: LogVariablesModel;\n  readonly writeVariables: LogVariablesModel | Nothing;\n  readonly entries: readonly ExecutionLogModel[];\n}\n\nfunction mapExecutionLog(entry: ExecutionLogEntry): ExecutionLogModel {\n  return {\n    message: entry.message,\n    readVariables: entry.readVariables,\n    writeVariables: entry.writeVariables,\n    entries: mapExecutionLogging(entry.entries)\n  };\n}\n\nexport function mapExecutionLogging(entries: readonly ExecutionLogEntry[]): ExecutionLogModel[] {\n  return entries.map(mapExecutionLog);\n}\n","import {FunctionResult} from \"lexy/dist/runTime/functionResult\";\n\n\nexport type ParametersValueModel = Date | string | number | boolean | ParametersModel;\n\nexport type ParametersModel = {[key: string]: ParametersValueModel};\n\nexport type ResultsValueModel = Date | string | number | boolean | ResultsModel;\n\nexport type ResultsModel = {[key: string]: ResultsValueModel};\n\nexport function mapExecutionResults(results: FunctionResult): ResultsModel {\n  return results.value;\n}\n","import {nothing, Nothing} from \"../../infrastructure/nothing\";\nimport {ExecutionLogModel, mapExecutionLogging} from \"./executionLogModel\";\nimport {SpecificationsLogEntry} from \"lexy/dist/specifications/specificationsLogEntry\";\n\nexport type SpecificationsLogModel = {\n  readonly nodeName: string | Nothing;\n  readonly characterNumber: number | Nothing;\n  readonly lineNumber: number | Nothing;\n  readonly fileName: string | Nothing;\n  readonly isError: boolean;\n  readonly message: string;\n  readonly errors: Array<string> | null;\n  readonly executionLogging: readonly ExecutionLogModel[] | Nothing;\n}\n\nfunction mapSpecificationsLogModel(result: SpecificationsLogEntry): SpecificationsLogModel {\n  return {\n    nodeName: result.node ? result.node.nodeName : nothing,\n    characterNumber: result.reference ? result.reference.characterNumber : nothing,\n    lineNumber: result.reference ? result.reference.lineNumber : nothing,\n    fileName: result.reference?.file ? result.reference.file.fileName : nothing,\n    isError: result.isError,\n    message: result.message,\n    errors: result.errors,\n    executionLogging: result.executionLogging ? mapExecutionLogging(result.executionLogging) : nothing\n  }\n}\n\nexport function mapSpecificationsLog(result: readonly SpecificationsLogEntry[]): readonly SpecificationsLogModel[] {\n  return result.map(mapSpecificationsLogModel);\n}\n","import {WebFileSystem} from \"../../api/webFileSystem\";\nimport {compileNodes, parseCode, parseFile} from \"../../api/parser\";\nimport {mapNodes} from \"../project/nodeModel\";\nimport {mapLogging} from \"../project/logModel\";\nimport {\n  Response,\n  CompilationFailedResponse,\n  CompilationSuccessResponse,\n  RunFunctionSuccessResponse,\n  RunFunctionFailedResponse, ResponseType, RunScenariosResponse\n} from \"./response\";\nimport {Request, RequestType, RunFunctionRequest, StartCompilationRequest} from \"./requests\";\nimport {milliseconds} from \"../../infrastructure/dateFunctions\";\nimport {Assert} from \"lexy\";\nimport {mapExecutionLogging} from \"./executionLogModel\";\nimport {mapExecutionResults} from \"./resultsModel\";\nimport {runScenarios} from \"./runScenarios\";\nimport {ComponentNodeList} from \"lexy/dist/language/componentNodeList\";\nimport {IParserLogger} from \"lexy/dist/parser/parserLogger\";\nimport {mapSpecificationsLog} from \"./specificationsLogModel\";\nimport {Dependencies} from \"lexy/dist/dependencyGraph/dependencies\";\nimport {asFunction} from \"lexy/dist/language/functions/function\";\nimport {asScenario, instanceOfScenario} from \"lexy/dist/language/scenarios/scenario\";\nimport {workerOperationStateStorage} from \"../../api/operationStorage\";\n\nexport const operationKey = \"compilation-worker\";\n\nasync function processWorkerRequest(message: MessageEvent<Request>): Promise<void> {\n\n  const {getOperationState} = workerOperationStateStorage();\n\n  async function processStartCompilation(request: StartCompilationRequest) {\n\n    async function parseFiles(request: StartCompilationRequest) {\n\n      const fileSystem = new WebFileSystem(request.folder);\n      const {logging, nodes, logger, elapsed, dependencies} = await parseCode(request.fileName, request.code, fileSystem);\n      const response: CompilationSuccessResponse = {\n        type: ResponseType.CompilationCompleted,\n        error: false,\n        logging: mapLogging(logging),\n        nodes: mapNodes(nodes.values),\n        elapsed: elapsed\n      };\n\n      if (await continueOperation()) {\n        postResponse(response);\n        return {nodes, logger, elapsed, dependencies};\n      } else {\n        return null;\n      }\n    }\n\n    async function continueOperation(): Promise<boolean> {\n      let operationState = await getOperationState(operationKey);\n      let continueValue = operationState === request.timestamp;\n      if (!continueValue) {\n        console.log(`CANCEL CURRENT OPERATION: ${operationState} (new: ${request.timestamp})`);\n      }\n      return continueValue;\n    }\n\n    async function runFileScenarios(fileName: string, nodes: ComponentNodeList, dependencies: Dependencies, logger: IParserLogger) {\n      const result = await runScenarios(fileName, nodes, dependencies, logger, continueOperation);\n      const response: RunScenariosResponse = {\n        type: ResponseType.RunScenariosCompleted,\n        result: mapSpecificationsLog(result),\n      };\n      postResponse(response);\n    }\n\n    try {\n      const result = await parseFiles(request);\n      if (!result) return;\n\n      const {nodes, logger, dependencies} = result;\n      await runFileScenarios(request.fileName, nodes, dependencies, logger);\n    } catch (error: any) {\n      const failed: CompilationFailedResponse = {type: ResponseType.CompilationFailed, error: true, lastError: error.stack};\n      postResponse(failed);\n    }\n  }\n\n  async function processExecuteFunction(request: RunFunctionRequest) {\n    const startTime = new Date();\n    try {\n      const fileSystem = new WebFileSystem(request.folder);\n      const {nodes} = await parseFile(request.fileName, fileSystem);\n      const result = compileNodes(nodes.values);\n\n      const node = nodes.getNode(request.functionName);\n      const functionNode = instanceOfScenario(node) ? asScenario(node)?.functionNode : asFunction(node);\n      const executable = result.getFunction(Assert.notNull(functionNode, \"functionNode\"));\n      const parameters = request.parameters;\n      const results = executable.run(parameters);\n      const elapsed = milliseconds(new Date(), startTime).toNumber();\n\n      const response: RunFunctionSuccessResponse = {\n        type: ResponseType.RunFunctionCompleted,\n        error: false,\n        logging: mapExecutionLogging(results.logging),\n        result: mapExecutionResults(results),\n        elapsed: elapsed\n      };\n\n      postResponse(response);\n\n    } catch (error: any) {\n      const failed: RunFunctionFailedResponse = {type: ResponseType.RunFunctionCompleted, error: true, lastError: error.stack};\n      postResponse(failed);\n    }\n  }\n\n  function postResponse(response: Response) {\n    self.postMessage(response);\n  }\n\n  if (message.data.type === RequestType.StartCompilation) {\n    await processStartCompilation(message.data as StartCompilationRequest);\n  } else if (message.data.type === RequestType.RunFunction) {\n    await processExecuteFunction(message.data as RunFunctionRequest);\n  } else {\n    console.log(\"Invalid compile worker request: \" + JSON.stringify(message.data));\n  }\n}\n\nconst self = globalThis as unknown as DedicatedWorkerGlobalScope;\nself.onmessage = processWorkerRequest;\n","import type {IParserLogger} from \"lexy/dist/parser/parserLogger\";\n\nimport {NodeType} from \"lexy/dist/language/nodeType\";\nimport {ScenarioRunner} from \"lexy/dist/specifications/scenarioRunner\";\nimport {asScenario} from \"lexy/dist/language/scenarios/scenario\";\nimport {createLexyCompiler} from \"../../api/parser\";\nimport {Assert, ILexyCompiler} from \"lexy\";\nimport {SpecificationRunnerContext} from \"lexy/dist/specifications/specificationRunnerContext\";\nimport {SpecificationsLogEntry} from \"lexy/dist/specifications/specificationsLogEntry\";\nimport {ComponentNodeList} from \"lexy/dist/language/componentNodeList\";\nimport {MemoryLogger} from \"../../infrastructure/loggers\";\nimport {Dependencies} from \"lexy/dist/dependencyGraph/dependencies\";\n\nexport async function runScenarios(currentFileName: string, nodes: ComponentNodeList, dependencies: Dependencies,\n                             parserLogger: IParserLogger,\n                             continueCheck: () => Promise<boolean>): Promise<readonly SpecificationsLogEntry[]> {\n\n  function addRunners(lexyCompiler: ILexyCompiler, context: SpecificationRunnerContext, scenarioRunners: Array<ScenarioRunner>) {\n    for (const node of nodes.values) {\n      if (node.nodeType !== NodeType.Scenario) continue;\n      const scenario = Assert.notNull(asScenario(node), \"scenario\");\n      const runner = new ScenarioRunner(currentFileName, lexyCompiler, nodes, scenario, context, parserLogger, dependencies);\n      scenarioRunners.push(runner)\n    }\n  }\n\n  async function runRunners(scenarioRunners: Array<ScenarioRunner>): Promise<void> {\n    for (const scenarioRunner of scenarioRunners) {\n      console.log(\"scenarioRunner: \" + scenarioRunner.scenario.name);\n      if (!await continueCheck()) return;\n      scenarioRunner.run()\n    }\n  }\n\n  try {\n    const lexyCompiler = createLexyCompiler();\n    const logger = new MemoryLogger();\n    const context = new SpecificationRunnerContext(logger)\n    const scenarioRunners: Array<ScenarioRunner> = [];\n\n    addRunners(lexyCompiler, context, scenarioRunners);\n    await runRunners(scenarioRunners);\n    context.logTimeSpent();\n    //console.log(\"scenarioRunner: complete \" + JSON.stringify(context.logEntries, null, 4));\n\n    return context.logEntries;\n  } catch (error: any) {\n    console.log(\"scenarioRunner: error \" + error);\n    const entry = new SpecificationsLogEntry(null, null, true, \"Application error occurred: \" + error.stack);\n    return [entry];\n  }\n}\n","import {useMemo} from \"react\";\nimport {IndexedDBStore, windowIndexedDBStore, workerIndexedDBStore} from \"./indexedDb/indexedDBStore\";\nimport {idbConfig} from \"./idbConfig\";\n\ninterface Operation {\n  id: string,\n  timestamp: string\n}\n\nexport interface OperationStateStorage {\n  getOperationState(key: string): Promise<string | null>;\n  updateOperationState(key: string, timestamp: string): Promise<void>;\n}\n\nfunction operationStorage(filesStore: IndexedDBStore<Operation>): OperationStateStorage {\n\n  const {getByID, update} = filesStore;\n\n  async function getOperationState(key: string): Promise<string | null> {\n    const value = await getByID(key);\n    return value != null ? value.timestamp : null;\n  }\n\n  async function updateOperationState(key: string, timestamp: string): Promise<void> {\n    await update({id: key, timestamp: timestamp}, key);\n  }\n\n  return {\n    getOperationState: getOperationState,\n    updateOperationState: updateOperationState\n  }\n}\n\nexport function useOperationStateStorage(): OperationStateStorage {\n  const store = useMemo(() => {\n    const storeOperationState = windowIndexedDBStore<Operation>(idbConfig, \"operation-state\");\n    return operationStorage(storeOperationState);\n  }, []);\n  return store;\n}\n\nexport function workerOperationStateStorage(): OperationStateStorage {\n  const storeOperationState = workerIndexedDBStore<Operation>(idbConfig, \"operation-state\");\n  return operationStorage(storeOperationState);\n}\n","//adapted from use use-indexeddb (https://github.com/hc-oss/use-indexeddb/commit/f6e5deed3f3c1010c4b314d72b25b5a4f454f07f)\n\nexport interface IndexedDBColumn {\n  name: string;\n  keyPath: string;\n  options?: IDBIndexParameters;\n}\n\nexport interface IndexedDBStoreConfig {\n  name: string;\n  id: IDBObjectStoreParameters;\n  indices: IndexedDBColumn[];\n}\n\nexport interface IndexedDBConfig {\n  databaseName: string;\n  version: number;\n  stores: IndexedDBStoreConfig[];\n}\n\nexport interface IndexedDBStore<T> {\n  getByID(id: string | number): Promise<T>;\n  getOneByKey(keyPath: string, value: string | number): Promise<T | undefined>;\n  getManyByKey(keyPath: string, value: string | number): Promise<T[]>;\n  getAll(): Promise<T[]>;\n  add(value: T, key?: any): Promise<number>;\n  addIfNew(value: T, key?: any): Promise<number | null>;\n  update(value: T, key?: any): Promise<any>;\n  deleteByID(id: any): Promise<any>;\n  deleteAll(): Promise<any>;\n  openCursor(cursorCallback: (e: any) => void, keyRange?: IDBKeyRange): Promise<IDBCursorWithValue | void>;\n}\n\nconst self = globalThis as unknown as DedicatedWorkerGlobalScope;\n\nexport function createIndexedDBStore<T>(factory: IDBFactory, config: IndexedDBConfig, currentStore: string) {\n\n  let transaction = 0;\n\n  function validateStore(db: IDBDatabase, storeName: string) {\n    return db.objectStoreNames.contains(storeName);\n  }\n\n  function validateBeforeTransaction(db: IDBDatabase, storeName: string, reject: Function) {\n    if (!db) {\n      reject(\"Queried before opening connection\");\n      return false;\n    }\n    if (!validateStore(db, storeName)) {\n      reject(`Store ${storeName} not found`);\n      return false;\n    }\n    return true;\n  }\n\n  function createTransaction(\n    db: IDBDatabase,\n    dbMode: IDBTransactionMode,\n    currentStore: string,\n    resolve: ((this: IDBTransaction, ev: Event) => any) | null,\n    reject: ((this: IDBTransaction, ev: Event) => any) | null,\n    abort: ((this: IDBTransaction, ev: Event) => any) | null = null\n  ): IDBTransaction {\n    let tx: IDBTransaction = db.transaction(currentStore, dbMode);\n    tx.onerror = reject;\n    tx.oncomplete = resolve;\n    tx.onabort = abort;\n    return tx;\n  }\n\n  async function getConnection(): Promise<IDBDatabase> {\n    const idbInstance = self ? self.indexedDB : null;\n\n    return new Promise<IDBDatabase>((resolve, reject) => {\n      if (!idbInstance) {\n        return reject(\"IndexedDB is null\");\n      }\n\n      const request: IDBOpenDBRequest = idbInstance.open(config.databaseName, config.version);\n\n      request.onsuccess = () => {\n        resolve(request.result);\n      };\n\n      request.onerror = (e: any) => {\n        reject(e.target.error.name);\n      };\n\n      request.onupgradeneeded = (e: any) => {\n        const db = e.target.result;\n        config.stores.forEach(s => {\n          if (!db.objectStoreNames.contains(s.name)) {\n            const store = db.createObjectStore(s.name, s.id);\n            s.indices.forEach(c => {\n              store.createIndex(c.name, c.keyPath, c.options);\n            });\n          }\n        });\n      };\n    });\n  }\n\n  function getByID(id: string | number) {\n    const thisTransaction = ++transaction;\n    console.log(`getByID: ${id}(${thisTransaction})`)\n    return new Promise<T>((resolve, reject) => {\n      getConnection()\n        .then(db => {\n          if (!validateBeforeTransaction(db, currentStore, reject)) return;\n          let tx = createTransaction(db, \"readonly\", currentStore, (e) => console.log(\"Transaction getByID completed: \" + JSON.stringify(e)), reject, null);\n          let objectStore = tx.objectStore(currentStore);\n          let request = objectStore.get(id);\n          request.onsuccess = (e: any) => {\n            console.log(`getByID: ${id}(${thisTransaction}): `, e.target.result, \"...\");\n            resolve(e.target.result as T);\n          };\n          request.onerror = (e: any) => {\n            console.log(`getByID: ${id}(${thisTransaction}): error `, e.target.result);\n            reject(e.target.result as T);\n          };\n        })\n        .catch(reject);\n    });\n  }\n\n  function getOneByKey(keyPath: string, value: string | number) {\n    return new Promise<T | undefined>((resolve, reject) => {\n      getConnection()\n        .then(db => {\n          if (!validateBeforeTransaction(db, currentStore, reject)) return;\n          let tx = createTransaction(db, \"readonly\", currentStore, (e) => console.log(\"Transaction getOneByKey completed: \" + JSON.stringify(e)), reject);\n          let objectStore = tx.objectStore(currentStore);\n          let index = objectStore.index(keyPath);\n          let request = index.get(value);\n          request.onsuccess = (e: any) => {\n            resolve(e.target.result);\n          };\n        })\n        .catch(reject);\n    });\n  }\n\n  function getManyByKey(keyPath: string, value: string | number) {\n    return new Promise<T[]>((resolve, reject) => {\n      getConnection()\n        .then(db => {\n          if (!validateBeforeTransaction(db, currentStore, reject)) return;\n          let tx = createTransaction(db, \"readonly\", currentStore, (e) => console.log(\"Transaction getManyByKey completed: \" + JSON.stringify(e)), reject);\n          let objectStore = tx.objectStore(currentStore);\n          let index = objectStore.index(keyPath);\n          let request = index.getAll(value);\n          request.onsuccess = (e: any) => {\n            resolve(e.target.result);\n          };\n        })\n        .catch(reject);\n    });\n  }\n\n  function getAll() {\n    return new Promise<T[]>((resolve, reject) => {\n      getConnection()\n        .then(db => {\n          if (!validateBeforeTransaction(db, currentStore, reject)) return;\n          let tx = createTransaction(db, \"readonly\", currentStore, () => console.log(\"getAll.validateBeforeTransaction.resolve\"), reject);\n          let objectStore = tx.objectStore(currentStore);\n          let request = objectStore.getAll();\n          request.onsuccess = (e: any) => {\n            resolve(e.target.result as T[]);\n          };\n        })\n        .catch(reject);\n    });\n  }\n\n  function add(value: T, key?: any) {\n    return new Promise<number>((resolve, reject) => {\n      getConnection()\n        .then(db => {\n          if (!validateBeforeTransaction(db, currentStore, reject)) return;\n          let tx = createTransaction(db, \"readwrite\", currentStore, (e) => console.log(\"Transaction add completed: \" + JSON.stringify(e)), reject);\n          let objectStore = tx.objectStore(currentStore);\n          let request = objectStore.add(value);\n          request.onsuccess = (e: any) => {\n            (tx as any)?.commit?.();\n            resolve(e.target.result);\n          };\n        })\n        .catch(reject);\n    });\n  }\n\n  function addIfNew(value: T, key?: any) {\n    return new Promise<number | null>((resolve, reject) => {\n      getConnection()\n        .then(db => {\n          if (!validateBeforeTransaction(db, currentStore, reject)) return;\n          let tx = createTransaction(db, \"readwrite\", currentStore, (e) => console.log(\"Transaction add completed: \" + JSON.stringify(e)), reject);\n          let objectStore = tx.objectStore(currentStore);\n          let request = objectStore.get(key);\n          request.onsuccess = (e: any) => {\n            if (e.target.result) {\n              tx.abort();\n              return resolve(null);\n            }\n\n            let request = objectStore.add(value);\n            request.onsuccess = (e: any) => {\n              tx.commit();\n              resolve(e.target.result);\n            };\n          };\n        })\n        .catch(reject);\n    });\n  }\n\n  function update(value: T, key?: any) {\n    console.trace();\n    console.log(`Update: ${key}(${++transaction}) - ${JSON.stringify(value)}`)\n    return new Promise<any>((resolve, reject) => {\n      getConnection()\n        .then(db => {\n\n          if (!validateBeforeTransaction(db, currentStore, reject)) return;\n          let tx = createTransaction(db, \"readwrite\", currentStore, (e) => console.log(`Transaction update completed: ${key}(${transaction}) - ${JSON.stringify(e)}`), reject);\n          let objectStore = tx.objectStore(currentStore);\n          let request = objectStore.put(value);\n          request.onsuccess = (e: any) => {\n            tx.commit();\n            resolve(e.target.result);\n          };\n        })\n        .catch(reject);\n    });\n  }\n\n  function deleteByID(id: any) {\n    return new Promise<any>((resolve, reject) => {\n      getConnection()\n        .then(db => {\n          if (!validateBeforeTransaction(db, currentStore, reject)) return;\n          let tx = createTransaction(db, \"readwrite\", currentStore, (e) => console.log(\"Transaction deleteByID completed: \" + JSON.stringify(e)), reject);\n          let objectStore = tx.objectStore(currentStore);\n          let request = objectStore.delete(id);\n          request.onsuccess = (e: any) => {\n            (tx as any)?.commit?.();\n            resolve(e);\n          };\n        })\n        .catch(reject);\n    });\n  }\n\n  function deleteAll() {\n    return new Promise<any>((resolve, reject) => {\n      getConnection()\n        .then(db => {\n          if (!validateBeforeTransaction(db, currentStore, reject)) return;\n          let tx = createTransaction(db, \"readwrite\", currentStore, (e) => console.log(\"Transaction deleteAll completed: \" + JSON.stringify(e)), reject);\n          let objectStore = tx.objectStore(currentStore);\n          let request = objectStore.clear();\n          request.onsuccess = (e: any) => {\n            (tx as any)?.commit?.();\n            resolve(e);\n          };\n        })\n        .catch(reject);\n    });\n  }\n\n  function openCursor(cursorCallback: (e: any) => void, keyRange?: IDBKeyRange) {\n    return new Promise<IDBCursorWithValue | void>((resolve, reject) => {\n      getConnection()\n        .then(db => {\n          if (!validateBeforeTransaction(db, currentStore, reject)) return;\n          let tx = createTransaction(db, \"readonly\", config.databaseName, (e) => console.log(\"Transaction openCursor completed: \" + JSON.stringify(e)), reject);\n          let objectStore = tx.objectStore(config.databaseName);\n          let request = objectStore.openCursor(keyRange);\n          request.onsuccess = e => {\n            cursorCallback(e);\n            resolve();\n          };\n        })\n        .catch(reject);\n    });\n  }\n\n  return {\n    add: add,\n    addIfNew: addIfNew,\n    update: update,\n    deleteByID: deleteByID,\n    deleteAll: deleteAll,\n    openCursor: openCursor,\n    getByID: getByID,\n    getAll: getAll,\n    getManyByKey: getManyByKey,\n    getOneByKey: getOneByKey,\n  };\n}\n\nexport function workerIndexedDBStore<T>(config: IndexedDBConfig, storeName: string): IndexedDBStore<T> {\n  return createIndexedDBStore<T>(self.indexedDB, config, storeName);\n}\n\nexport function windowIndexedDBStore<T>(config: IndexedDBConfig, storeName: string): IndexedDBStore<T> {\n  return createIndexedDBStore<T>(window.indexedDB, config, storeName);\n}\n","export const idbConfig = {\n  databaseName: \"lexy\",\n  version: 2,\n  stores: [\n    {\n      name: \"operation-state\",\n      id: { keyPath: \"id\", autoIncrement: false },\n      indices: []\n    },\n    {\n      name: \"code-files\",\n      id: { keyPath: \"id\", autoIncrement: true },\n      indices: []\n    }\n  ]\n};\n","import type {INode} from \"lexy/dist/language/node\";\n\nimport {Function} from \"lexy/dist/language/functions/function\";\nimport {NodeType} from \"lexy/dist/language/nodeType\";\nimport {VariableType} from \"lexy/dist/language/variableTypes/variableType\";\nimport {asPrimitiveType} from \"lexy/dist/language/variableTypes/primitiveType\";\nimport {TypeNames} from \"lexy/dist/language/variableTypes/typeNames\";\nimport {VariableTypeName} from \"lexy/dist/language/variableTypes/variableTypeName\";\nimport {asComponentNode} from \"lexy/dist/language/componentNode\";\nimport {Assert} from \"lexy\";\nimport {asVariableDefinition} from \"lexy/dist/language/variableDefinition\";\nimport {asVariableDeclarationExpression} from \"lexy/dist/language/expressions/variableDeclarationExpression\";\nimport {asAssignmentDefinition} from \"lexy/dist/language/scenarios/assignmentDefinition\";\nimport {asColumnHeader} from \"lexy/dist/language/tables/columnHeader\";\nimport {nothing, Nothing} from \"../../infrastructure/nothing\";\nimport {asGeneratedType} from \"lexy/dist/language/variableTypes/generatedType\";\nimport {asDeclaredType} from \"lexy/dist/language/variableTypes/declaredType\";\nimport {asEnumType} from \"lexy/dist/language/variableTypes/enumType\";\nimport {asEnumMember} from \"lexy/dist/language/enums/enumMember\";\n\nexport enum NodeKind {\n  Unknown = \"Unknown\",\n  Function = \"Function\",\n  Scenario = \"Scenario\",\n  Table = \"Table\",\n  Type = \"Type\",\n  Enum = \"Enum\",\n\n  Code = \"Code\",\n  Results = \"Results\",\n  Parameters = \"Parameters\",\n  EnumMember = \"EnumMember\",\n  Errors = \"Errors\",\n  Number = \"Number\",\n  Boolean = \"Boolean\",\n  Date = \"Date\",\n  String = \"String\",\n\n  Expression = \"Expression\",\n}\n\nexport interface NodeModel {\n  readonly name: string;\n  readonly kind: NodeKind;\n  readonly fileName: string;\n  readonly lineNumber: number;\n  readonly characterNumber: number;\n  readonly children: readonly NodeModel[];\n  readonly nodeType: NodeType;\n}\n\nexport interface FunctionNodeModel extends NodeModel {\n  readonly kind: NodeKind.Function;\n  readonly parameters: readonly VariableModel[];\n}\n\nexport enum TypeKind {\n  Unsupported,\n  Primitive,\n  Enum,\n  Object,\n}\n\nexport interface TypeModel {\n  readonly kind: TypeKind;\n  readonly name: string;\n}\n\nexport interface EnumTypeModel extends TypeModel {\n  readonly kind: TypeKind.Enum;\n  readonly members: string[]\n}\n\nexport interface ObjectTypeModel extends TypeModel {\n  readonly kind: TypeKind.Object;\n  readonly variables: VariableModel[];\n}\n\nexport interface VariableModel {\n  readonly name: string;\n  readonly type: TypeModel;\n}\n\nexport function mapNodes(nodes: readonly INode[]): NodeModel[] {\n\n  const typesCache: {[key: string]: TypeModel} = {};\n\n  function mapTypeToKind(variableType: VariableType | Nothing | undefined): NodeKind  {\n\n    function mapValueType() {\n      const primitiveType = asPrimitiveType(variableType);\n      switch (primitiveType?.type) {\n        case TypeNames.number:\n          return NodeKind.Number;\n        case TypeNames.boolean:\n          return NodeKind.Boolean;\n        case TypeNames.date:\n          return NodeKind.Date;\n        case TypeNames.string:\n          return NodeKind.String;\n        default:\n          return NodeKind.Unknown;\n      }\n    }\n\n    switch (variableType?.variableTypeName) {\n      case VariableTypeName.TableType:\n        return NodeKind.Table;\n      case VariableTypeName.EnumType:\n        return NodeKind.Enum;\n      case VariableTypeName.DeclaredType:\n        return NodeKind.Type;\n      case VariableTypeName.GeneratedType:\n        return NodeKind.Type;\n      case VariableTypeName.PrimitiveType:\n        return mapValueType();\n      case VariableTypeName.FunctionType:\n        return NodeKind.Function;\n\n      case VariableTypeName.VoidType:\n      case nothing:\n      default:\n        return NodeKind.Unknown;\n    }\n  }\n\n  function mapType(variableType: VariableType | Nothing): TypeModel {\n\n    function mapPrimitiveType(): TypeModel {\n      let primitiveType = Assert.notNull(asPrimitiveType(variableType), \"asPrimitiveType\");\n      return {\n        kind: TypeKind.Primitive,\n        name: primitiveType.type\n      };\n    }\n\n    function fromCache<T extends TypeModel>(name: string, factory: () => T): T {\n      if (typesCache[name]) return typesCache[name] as T;\n      const type = factory();\n      typesCache[name] = type;\n      return type;\n    }\n\n    function mapGeneratedType () {\n      let objectType = Assert.notNull(asGeneratedType(variableType), \"asGeneratedType\");\n      return fromCache<ObjectTypeModel>(objectType.name, () => ({\n        kind: TypeKind.Object,\n        name: objectType.name,\n        variables: objectType.members.map(member => ({name: member.name, type: mapType(member.type)}))\n      }));\n    }\n\n    function mapDeclaredType() {\n      let objectType = Assert.notNull(asDeclaredType(variableType), \"asDeclaredType\");\n      return fromCache<ObjectTypeModel>(objectType.type, () => ({\n        kind: TypeKind.Object,\n        name: objectType.type,\n        variables: objectType.typeDefinition.variables.map(member => ({name: member.name, type: mapType(member.variableType)}))\n      }));\n    }\n\n    function mapEnumType() {\n      let enumType = Assert.notNull(asEnumType(variableType), \"asGeneratedType\");\n      return fromCache<EnumTypeModel>(enumType.type, () => ({\n        kind: TypeKind.Enum,\n        name: enumType.type,\n        members: enumType.enum.members.map(member => member.name)\n      }));\n    }\n\n    switch (variableType?.variableTypeName) {\n      case VariableTypeName.PrimitiveType:\n        return mapPrimitiveType();\n      case VariableTypeName.GeneratedType:\n        return mapGeneratedType();\n      case VariableTypeName.DeclaredType:\n        return mapDeclaredType();\n      case VariableTypeName.EnumType:\n        return mapEnumType();\n\n      case VariableTypeName.FunctionType:\n      case VariableTypeName.TableType:\n      default:\n        return {kind: TypeKind.Unsupported, name: variableType?.variableTypeName ?? \"nothing\"}\n    }\n  }\n\n  function mapParameters(functionNode: Function): readonly VariableModel[] {\n    return functionNode.parameters.variables.map(variabel => ({\n      name: variabel.name,\n      type: mapType(variabel.variableType),\n    }));\n  }\n\n  function mapFunction(node: INode): FunctionNodeModel {\n    const functionNode = createNode(node, NodeKind.Function);\n    const parameters = mapParameters(node as Function);\n    return {...functionNode, kind: NodeKind.Function, parameters: parameters};\n  }\n\n  function createNode(node: INode, kind: NodeKind, name: string | Nothing = nothing,  mapChildren: boolean = true): NodeModel {\n\n    const componentNode = asComponentNode(node);\n    const componentNodeName = componentNode ? componentNode.nodeName : \"\";\n\n    const children = mapChildren ? mapNodes(node.getChildren()) : [];\n\n    return {\n      name: name ?? componentNodeName,\n      kind: kind,\n      children: children,\n      fileName: node.reference.file.fileName,\n      lineNumber: node.reference.lineNumber,\n      characterNumber: node.reference.characterNumber,\n      nodeType: node.nodeType\n    }\n  }\n\n  function mapVariableDefinition(node: INode) {\n    const definition = Assert.notNull(asVariableDefinition(node), \"variableDefinition\");\n    const functionNode = createNode(node, NodeKind.Function, definition.name);\n    return {...functionNode, kind: NodeKind.Function, type: mapType(definition.variableType)};\n  }\n\n  function mapNode(node: INode): NodeModel | Nothing {\n\n    switch (node.nodeType) {\n      case NodeType.FunctionName:\n      case NodeType.ScenarioName:\n      case NodeType.ScenarioFunctionName:\n      case NodeType.EnumName:\n      case NodeType.TableRow:\n        return null;\n\n      case NodeType.Function:\n        return mapFunction(node);\n      case NodeType.Scenario:\n        return createNode(node, NodeKind.Scenario);\n      case NodeType.Table:\n        return createNode(node, NodeKind.Table);\n      case NodeType.TypeDefinition:\n        return createNode(node, NodeKind.Type);\n      case NodeType.EnumDefinition:\n        return createNode(node, NodeKind.Enum);\n\n      case NodeType.FunctionResults:\n      case NodeType.ScenarioResults:\n        return createNode(node, NodeKind.Results, \"Results\");\n\n      case NodeType.FunctionParameters:\n      case NodeType.ScenarioParameters:\n        return createNode(node, NodeKind.Parameters, \"Parameters\");\n      case NodeType.FunctionCode:\n        return createNode(node, NodeKind.Code, \"Code\");\n      case NodeType.VariableDefinition: {\n        return mapVariableDefinition(node);\n      }\n      case NodeType.VariableDeclarationExpression: {\n        let expression = Assert.notNull(asVariableDeclarationExpression(node), \"variableDeclarationExpression\");\n        return createNode(node, mapTypeToKind(expression.type.variableType), nothing, false);\n      }\n      case NodeType.AssignmentDefinition: {\n        let definition = Assert.notNull(asAssignmentDefinition(node), \"variableDefinition\");\n        return createNode(node, mapTypeToKind(definition.variableType), definition.variable.path.join(\".\"), false);\n      }\n\n      case NodeType.EnumMember: {\n        let enumMember = Assert.notNull(asEnumMember(node), \"enumMember\");\n        return createNode(node, NodeKind.EnumMember, enumMember.name, false);\n      }\n\n      case NodeType.ScenarioExpectErrors:\n        return createNode(node, NodeKind.Errors, \"Expect Errors\", true);\n      case NodeType.ScenarioExpectComponentErrors:\n        return createNode(node, NodeKind.Errors, \"Expect Component Error\", true);\n\n      case NodeType.TableHeader:\n        return createNode(node, NodeKind.Table, \"Header\", true);\n\n      case NodeType.ColumnHeader: {\n        const column = Assert.notNull(asColumnHeader(node), \"columnHeader\");\n        return createNode(node, mapTypeToKind(column.type?.variableType), column.name, false);\n      }\n\n      default: {\n        if (node.nodeType.endsWith(\"Expression\")) {\n          return createNode(node, NodeKind.Expression, node.nodeType, true);\n        }\n        return createNode(node, NodeKind.Unknown, node.nodeType, true);\n      }\n    }\n  }\n\n  function mapNodeValues(children: readonly INode[]) {\n    const result = new Array<NodeModel>();\n    for (const node of children) {\n      const nodeModel = mapNode(node);\n      if (nodeModel !== null) {\n        result.push(nodeModel);\n      }\n    }\n    return result;\n  }\n\n  return mapNodeValues(nodes);\n}\n","export const nothing = null;\n\nexport type Nothing = null;\n","import {NodeModel} from \"../project/nodeModel\";\nimport {LogModel} from \"../project/logModel\";\nimport {ResultsModel} from \"./resultsModel\";\nimport {ExecutionLogModel} from \"./executionLogModel\";\nimport {SpecificationsLogModel} from \"./specificationsLogModel\";\n\nexport enum ResponseType {\n  CompilationCompleted,\n  CompilationFailed,\n  RunFunctionCompleted,\n  RunScenariosCompleted\n}\n\nexport type CompilationSuccessResponse = {\n  readonly type: ResponseType.CompilationCompleted;\n  readonly error: false;\n  readonly logging: readonly LogModel[];\n  readonly nodes: readonly NodeModel[];\n  readonly elapsed: number;\n}\n\nexport type CompilationFailedResponse = {\n  readonly type: ResponseType.CompilationFailed;\n  readonly error: true;\n  readonly lastError: string;\n}\n\nexport type RunScenariosResponse = {\n  readonly type: ResponseType.RunScenariosCompleted;\n  readonly result: readonly SpecificationsLogModel[],\n};\n\nexport type RunFunctionSuccessResponse = {\n  readonly type: ResponseType.RunFunctionCompleted;\n  readonly error: false;\n  readonly logging: readonly ExecutionLogModel[];\n  readonly result: ResultsModel;\n  readonly elapsed: number;\n}\n\nexport type RunFunctionFailedResponse = {\n  readonly type: ResponseType.RunFunctionCompleted;\n  readonly error: true;\n  readonly lastError: string;\n}\n\nexport type CompilationCompletedResponse = CompilationSuccessResponse | CompilationFailedResponse;\nexport type RunFunctionCompletedResponse = RunFunctionSuccessResponse | RunFunctionFailedResponse;\n\nexport type Response = CompilationCompletedResponse | RunScenariosResponse | RunFunctionCompletedResponse;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [4926], () => (__webpack_require__(35106)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and chunks that the entrypoint depends on\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"50683a82\" + \".chunk.js\";\n};","// This function allow to reference async chunks and chunks that the entrypoint depends on\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"https://lexy-language.github.io/lexy-editor/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t5106: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunklexy_editor\"] = self[\"webpackChunklexy_editor\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(4926).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["RequestType","codeFileStorage","filesStore","getByID","addIfNew","update","deleteAll","getCodeFile","identifier","Promise","resolve","reject","then","value","code","catch","storeCodeFile","override","id","_","clearCodeFiles","workerCodeFileStorage","workerIndexedDBStore","idbConfig","WebFileSystem","constructor","currentFolder","store","this","readAllLines","fileName","parts","isPathRooted","getFullPath","split","removeFirst","data","join","Error","getFileName","fullFileName","getDirectoryName","parentFullFileName","removeLast","length","folder","part","push","splice","combine","fullPath","fileParts","fileExists","directoryExists","absoluteFolder","startsWith","getDirectoryFiles","extension","getDirectories","logFolders","MemoryLogger","loggingValue","logging","isEnabled","level","logDebug","message","LogLevel","Debug","logError","logInformation","Information","baseLogger","async","parseCode","fileSystem","lines","startTime","Date","lexyParser","createParser","Libraries","componentNodes","logger","dependencies","parse","suppressException","elapsed","milliseconds","toNumber","entries","nodes","parseLines","createLexyCompiler","createCompiler","mapLogging","map","mapLogEntry","entry","reference","file","lineNumber","characterNumber","sortIndex","isError","end","start","laterDate","earlierDate","Decimal","mapExecutionLog","readVariables","writeVariables","mapExecutionLogging","mapExecutionResults","results","mapSpecificationsLogModel","result","_result$reference","nodeName","node","nothing","errors","executionLogging","mapSpecificationsLog","self","globalThis","onmessage","getOperationState","workerOperationStateStorage","postResponse","response","postMessage","type","StartCompilation","request","continueOperation","operationState","continueValue","timestamp","console","log","concat","ResponseType","CompilationCompleted","error","mapNodes","values","parseFiles","currentFileName","parserLogger","continueCheck","lexyCompiler","context","SpecificationRunnerContext","scenarioRunners","nodeType","NodeType","Scenario","scenario","Assert","notNull","asScenario","runner","ScenarioRunner","addRunners","scenarioRunner","name","run","runRunners","logTimeSpent","logEntries","SpecificationsLogEntry","stack","runScenarios","RunScenariosCompleted","runFileScenarios","CompilationFailed","lastError","processStartCompilation","RunFunction","_asScenario","parseFile","compile","compileNodes","getNode","functionName","functionNode","instanceOfScenario","asFunction","executable","getFunction","parameters","RunFunctionCompleted","processExecuteFunction","JSON","stringify","operationStorage","key","updateOperationState","createIndexedDBStore","factory","config","currentStore","transaction","validateBeforeTransaction","db","storeName","objectStoreNames","contains","validateStore","createTransaction","dbMode","abort","arguments","undefined","tx","onerror","oncomplete","onabort","getConnection","idbInstance","indexedDB","open","databaseName","version","onsuccess","e","target","onupgradeneeded","stores","forEach","s","createObjectStore","indices","c","createIndex","keyPath","options","add","objectStore","_commit","_ref","commit","call","get","trace","put","deleteByID","delete","_commit2","_ref2","clear","_commit3","_ref3","openCursor","cursorCallback","keyRange","thisTransaction","getAll","getManyByKey","index","getOneByKey","autoIncrement","NodeKind","TypeKind","typesCache","mapTypeToKind","variableType","variableTypeName","VariableTypeName","TableType","Table","EnumType","Enum","DeclaredType","GeneratedType","Type","PrimitiveType","primitiveType","asPrimitiveType","TypeNames","number","Number","boolean","Boolean","date","string","String","Unknown","mapValueType","FunctionType","Function","VoidType","mapType","_variableType$variabl","fromCache","kind","Primitive","mapPrimitiveType","objectType","asGeneratedType","Object","variables","members","member","mapGeneratedType","asDeclaredType","typeDefinition","mapDeclaredType","enumType","asEnumType","enum","mapEnumType","Unsupported","mapFunction","createNode","variabel","mapParameters","_objectSpread","mapChildren","componentNode","asComponentNode","componentNodeName","children","getChildren","mapNode","FunctionName","ScenarioName","ScenarioFunctionName","EnumName","TableRow","TypeDefinition","EnumDefinition","FunctionResults","ScenarioResults","Results","FunctionParameters","ScenarioParameters","Parameters","FunctionCode","Code","VariableDefinition","definition","asVariableDefinition","mapVariableDefinition","VariableDeclarationExpression","asVariableDeclarationExpression","AssignmentDefinition","asAssignmentDefinition","variable","path","EnumMember","enumMember","asEnumMember","ScenarioExpectErrors","Errors","ScenarioExpectComponentErrors","TableHeader","ColumnHeader","_column$type","column","asColumnHeader","endsWith","Expression","Array","nodeModel","mapNodeValues","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","x","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","i","fulfilled","j","keys","every","r","n","getter","__esModule","d","a","o","defineProperty","enumerable","f","chunkId","all","reduce","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next"],"ignoreList":[],"sourceRoot":""}