{"version":3,"file":"static/js/5106.9c1244ee.chunk.js","mappings":"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","sources":["context/compilation/requests.ts","api/codeStorage.ts","api/webFileSystem.ts","infrastructure/loggers.tsx","api/parser.tsx","context/project/logModel.tsx","infrastructure/dateFunctions.ts","context/compilation/executionLogModel.ts","context/compilation/resultsModel.ts","context/compilation/specificationsLogModel.ts","context/compilation/worker.ts","context/compilation/runScenarios.ts","api/operationStorage.ts","api/indexedDb/indexedDBStore.ts","api/idbConfig.ts","context/project/nodeModel.ts","infrastructure/nothing.ts","context/compilation/response.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import {ParametersModel} from \"./resultsModel\";\n\nexport enum RequestType {\n  StartCompilation,\n  RunFunction\n}\n\nexport type StartCompilationRequest = {\n  readonly type: RequestType.StartCompilation;\n  readonly folder: string[];\n  readonly fileName: string;\n  readonly code: string;\n  readonly timestamp: string;\n}\n\nexport type RunFunctionRequest = {\n  readonly type: RequestType.RunFunction;\n  readonly folder: string[];\n  readonly fileName: string;\n  readonly functionName: string;\n  readonly parameters: ParametersModel;\n}\n\nexport type Request = StartCompilationRequest | RunFunctionRequest;\n","import {useMemo} from \"react\";\nimport {IndexedDBStore, windowIndexedDBStore, workerIndexedDBStore} from \"./indexedDb/indexedDBStore\";\nimport {idbConfig} from \"./idbConfig\";\n\ninterface FileCode {\n  id: string,\n  code: string\n}\n\nexport interface CodeFileStorage {\n  getCodeFile(identifier: string): Promise<string | null>;\n  storeCodeFile(identifier: string, code: string, override: boolean): Promise<boolean>;\n  clearCodeFiles(): Promise<any>;\n}\n\nfunction codeFileStorage(filesStore: IndexedDBStore<FileCode>): CodeFileStorage {\n\n  const {getByID, addIfNew, update, deleteAll} = filesStore;\n\n  function getCodeFile(identifier: string): Promise<string | null> {\n    return new Promise<string | null>((resolve, reject) =>\n      getByID(identifier)\n        .then(value => value ? resolve(value.code) : resolve(null))\n        .catch(reject));\n  }\n\n  function storeCodeFile(identifier: string, code: string, override: boolean): Promise<boolean> {\n    if (!override) {\n      return new Promise<boolean>((resolve, reject) => {\n        addIfNew({id: identifier, code: code}, identifier)\n          .then(id => resolve(id != null))\n          .catch(reject);\n      });\n    }\n\n    return new Promise<boolean>((resolve, reject) => {\n      update({id: identifier, code: code}, identifier)\n        .then(_ => resolve(true))\n        .catch(reject);\n    });\n  }\n\n  function clearCodeFiles(): Promise<any> {\n    return deleteAll();\n  }\n\n  return {\n    getCodeFile: getCodeFile,\n    storeCodeFile: storeCodeFile,\n    clearCodeFiles: clearCodeFiles\n  }\n}\n\nexport function useCodeFileStorage(): CodeFileStorage {\n  return useMemo(() => {\n    const storeFiles = windowIndexedDBStore<FileCode>(idbConfig, \"code-files\");\n    return codeFileStorage(storeFiles);\n  }, []);\n}\n\nexport function workerCodeFileStorage(): CodeFileStorage {\n  const storeFiles = workerIndexedDBStore<FileCode>(idbConfig, \"code-files\");\n  return codeFileStorage(storeFiles);\n}\n","import {IFileSystem} from \"lexy\";\nimport {CodeFileStorage, workerCodeFileStorage} from \"./codeStorage\";\n\nexport class WebFileSystem implements IFileSystem {\n\n  private readonly currentFolder: string[];\n  private readonly store: CodeFileStorage;\n\n  constructor(currentFolder: string[]) {\n    this.currentFolder = currentFolder;\n    this.store = workerCodeFileStorage();\n  }\n\n  async readAllLines(fileName: string): Promise<string[]> {\n    const fullFile = this.isPathRooted(fileName) ? fileName : this.getFullPath(fileName);\n    const parts = fullFile.split(\"/\");\n    this.removeFirst(parts);\n    const data = await this.store.getCodeFile(parts.join(\"|\"));\n    if (!data) {\n      throw new Error(\"Couldn't load: \" + fileName);\n    }\n    return data.split(\"\\n\");\n  }\n\n  getFileName(fullFileName: string): string {\n    return fullFileName;\n  }\n\n  getDirectoryName(parentFullFileName: string): string {\n    const parts = parentFullFileName.split(\"/\");\n    this.removeLast(parts);\n    return parts.length > 0 ? parts.join(\"/\") : \"\";\n  }\n\n  getFullPath(fileName: string): string {\n    if (this.isPathRooted(fileName)) return fileName;\n\n    const parts = fileName.split(\"/\");\n    const folder = [...this.currentFolder];\n    for (const part of parts) {\n      if (part === \"..\") {\n        this.removeLast(folder);\n      } else {\n        folder.push(part)\n      }\n    }\n    const fullPath = folder.join(\"/\");\n    return \"/\" + fullPath;\n  }\n\n  private removeLast(folder: string[]) {\n    folder.splice(folder.length - 1, 1);\n  }\n\n  private removeFirst(folder: string[]) {\n    folder.splice(0, 1);\n  }\n\n  combine(fullPath: string, fileName: string): string {\n    if (fullPath.length === 0) return fileName;\n    const parts = fullPath.split(\"/\");\n    if (parts[parts.length - 1].length === 0) this.removeLast(parts);\n\n    const fileParts = fileName.split(\"/\");\n\n    for (const part of fileParts) {\n      if (part === \"..\") {\n        this.removeLast(parts);\n      } else {\n        parts.push(part)\n      }\n    }\n    return parts.join(\"/\");\n  }\n\n  async fileExists(fileName: string): Promise<boolean> {\n    const parts = fileName.split(\"/\");\n    if (parts[0].length === 0) this.removeFirst(parts);\n    const data = await this.store.getCodeFile(parts.join('|'));\n    return !!data;\n  }\n\n  async directoryExists(absoluteFolder: string): Promise<boolean> {\n    throw new Error(\"Not implemented.\")\n  }\n\n  isPathRooted(folder: string): boolean {\n    return folder.startsWith(\"/\");\n  }\n\n  async getDirectoryFiles(folder: string, extension: Array<string>): Promise<string[]> {\n    return [];\n  }\n\n  async getDirectories(folder: string): Promise<string[]> {\n    return [];\n  }\n\n  logFolders(): string {\n    return \"\";\n  }\n}\n","import {ILogger, LogLevel} from \"lexy\";\n\nexport class DummyLogger implements ILogger {\n\n  isEnabled(level: LogLevel): boolean {\n    return false;\n  }\n\n  logDebug(message: string): void {\n  }\n\n  logError(message: string): void {\n  }\n\n  logInformation(message: string): void {\n  }\n}\n\nexport type MemoryLogEntry = {\n  message: string,\n  level: LogLevel,\n}\n\nexport class MemoryLogger implements ILogger {\n\n  private loggingValue: Array<MemoryLogEntry> = [];\n\n  public get logging(): ReadonlyArray<MemoryLogEntry> {\n    return this.loggingValue;\n  }\n\n  isEnabled(level: LogLevel): boolean {\n    return true;\n  }\n\n  logDebug(message: string): void {\n    this.loggingValue.push({message: message, level: LogLevel.Debug});\n  }\n\n  logError(message: string): void {\n    this.loggingValue.push({message: message, level: LogLevel.Error});\n  }\n\n  logInformation(message: string): void {\n    this.loggingValue.push({message: message, level: LogLevel.Information});\n  }\n}","import {createCompiler, createParser, IFileSystem, ILexyCompiler} from \"lexy\";\nimport {IParserLogger, LogEntry} from \"lexy/dist/parser/parserLogger\";\nimport {IComponentNode} from \"lexy/dist/language/componentNode\";\nimport {CompilerResult} from \"lexy/dist/generation/compilerResult\";\nimport {DummyLogger} from \"../infrastructure/loggers\";\nimport {ComponentNodeList} from \"lexy/dist/language/componentNodeList\";\nimport {Libraries} from \"lexy/dist/functionLibraries/libraries\";\nimport {milliseconds} from \"lexy/dist/runTime/libraries/dateLibrary\";\nimport {Dependencies} from \"lexy/dist/dependencyGraph/dependencies\";\n\nexport type ParseResult = {\n  logger: IParserLogger;\n  logging: Array<LogEntry>;\n  nodes: ComponentNodeList;\n  elapsed: number;\n  dependencies: Dependencies\n}\n\nconst baseLogger = new DummyLogger();\n\nexport async function parseLines(fileName: string, lines: string[], fileSystem: IFileSystem): Promise<ParseResult> {\n  const startTime = new Date();\n  const lexyParser = createParser(baseLogger, fileSystem, new Libraries([]));\n  const {componentNodes, logger, dependencies} = await lexyParser.parse(lines, fileName, {suppressException: true});\n  const elapsed = milliseconds(new Date(), startTime).toNumber();\n  return {logging: logger.entries, nodes: componentNodes, logger: logger, elapsed: elapsed, dependencies: dependencies}\n}\n\nexport async function parseCode(fileName: string, code: string, fileSystem: IFileSystem): Promise<ParseResult> {\n  const lines = code.split(\"\\n\");\n  return await parseLines(fileName, lines, fileSystem);\n}\n\nexport async function parseFile(fileName: string, fileSystem: IFileSystem): Promise<ParseResult> {\n  const startTime = new Date();\n  const lexyParser = createParser(baseLogger, fileSystem, new Libraries([]));\n  const {componentNodes, logger, dependencies} = await lexyParser.parseFile(fileName, {suppressException: true});\n  const elapsed = milliseconds(new Date(), startTime).toNumber();\n  return {logging: logger.entries, nodes: componentNodes, logger: logger, elapsed: elapsed, dependencies: dependencies}\n}\n\nexport function createLexyCompiler(): ILexyCompiler {\n  return createCompiler(baseLogger, baseLogger, new Libraries([]));\n}\n\nexport function compileNodes(nodes: readonly IComponentNode[]): CompilerResult {\n  const lexyCompiler = createLexyCompiler();\n  return lexyCompiler.compile(nodes);\n}\n","import {LogEntry} from \"lexy/dist/parser/parserLogger\";\n\nexport interface LogModel {\n  readonly fileName: string;\n  readonly lineNumber: number;\n  readonly characterNumber: number;\n  readonly sortIndex: string;\n  readonly isError: boolean;\n  readonly message: string;\n}\n\nexport function mapLogging(logging: LogEntry[]): LogModel[] {\n  return logging.map(mapLogEntry);\n}\n\nexport function mapLogEntry(entry: LogEntry): LogModel {\n  return {\n    fileName: entry.reference.file.fileName,\n    lineNumber: entry.reference.lineNumber,\n    characterNumber: entry.reference.characterNumber,\n    sortIndex: entry.sortIndex,\n    isError: entry.isError,\n    message: entry.message\n  };\n}\n","import Decimal from \"decimal.js\";\n\nfunction differenceInMilliseconds(laterDate: Date, earlierDate: Date): Decimal {\n  return Decimal(+laterDate - +earlierDate);\n}\n\nexport function milliseconds(end: Date, start: Date): Decimal {\n  return differenceInMilliseconds(end, start);\n}\n","import {LogVariables} from \"lexy/dist/runTime/executionContext\";\nimport {ExecutionLogEntry} from \"lexy/dist/runTime/executionLogEntry\";\nimport {Nothing} from \"../../infrastructure/nothing\";\n\nexport type LogVariableModel = Date | string | number | boolean | LogVariables;\n\nexport type LogVariablesModel = {\n  [key: string]: LogVariableModel;\n};\n\nexport interface ExecutionLogModel {\n  readonly message: string;\n  readonly readVariables: LogVariablesModel;\n  readonly writeVariables: LogVariablesModel | Nothing;\n  readonly entries: readonly ExecutionLogModel[];\n}\n\nfunction mapExecutionLog(entry: ExecutionLogEntry): ExecutionLogModel {\n  return {\n    message: entry.message,\n    readVariables: entry.readVariables,\n    writeVariables: entry.writeVariables,\n    entries: mapExecutionLogging(entry.entries)\n  };\n}\n\nexport function mapExecutionLogging(entries: readonly ExecutionLogEntry[]): ExecutionLogModel[] {\n  return entries.map(mapExecutionLog);\n}\n","import {FunctionResult} from \"lexy/dist/runTime/functionResult\";\n\n\nexport type ParametersValueModel = Date | string | number | boolean | ParametersModel;\n\nexport type ParametersModel = {[key: string]: ParametersValueModel};\n\nexport type ResultsValueModel = Date | string | number | boolean | ResultsModel;\n\nexport type ResultsModel = {[key: string]: ResultsValueModel};\n\nexport function mapExecutionResults(results: FunctionResult): ResultsModel {\n  return results.value;\n}\n","import {nothing, Nothing} from \"../../infrastructure/nothing\";\nimport {ExecutionLogModel, mapExecutionLogging} from \"./executionLogModel\";\nimport {SpecificationsLogEntry} from \"lexy/dist/specifications/specificationsLogEntry\";\n\nexport type SpecificationsLogModel = {\n  readonly nodeName: string | Nothing;\n  readonly characterNumber: number | Nothing;\n  readonly lineNumber: number | Nothing;\n  readonly fileName: string | Nothing;\n  readonly isError: boolean;\n  readonly message: string;\n  readonly errors: Array<string> | null;\n  readonly executionLogging: readonly ExecutionLogModel[] | Nothing;\n}\n\nfunction mapSpecificationsLogModel(result: SpecificationsLogEntry): SpecificationsLogModel {\n  return {\n    nodeName: result.node ? result.node.name : nothing,\n    characterNumber: result.reference ? result.reference.characterNumber : nothing,\n    lineNumber: result.reference ? result.reference.lineNumber : nothing,\n    fileName: result.reference?.file ? result.reference.file.fileName : nothing,\n    isError: result.isError,\n    message: result.message,\n    errors: result.errors,\n    executionLogging: result.executionLogging ? mapExecutionLogging(result.executionLogging) : nothing\n  }\n}\n\nexport function mapSpecificationsLog(result: readonly SpecificationsLogEntry[]): readonly SpecificationsLogModel[] {\n  return result.map(mapSpecificationsLogModel);\n}\n","import {WebFileSystem} from \"../../api/webFileSystem\";\nimport {compileNodes, parseCode, parseFile} from \"../../api/parser\";\nimport {mapNodes} from \"../project/nodeModel\";\nimport {mapLogging} from \"../project/logModel\";\nimport {\n  Response,\n  CompilationFailedResponse,\n  CompilationSuccessResponse,\n  RunFunctionSuccessResponse,\n  RunFunctionFailedResponse, ResponseType, RunScenariosResponse\n} from \"./response\";\nimport {Request, RequestType, RunFunctionRequest, StartCompilationRequest} from \"./requests\";\nimport {milliseconds} from \"../../infrastructure/dateFunctions\";\nimport {Assert} from \"lexy\";\nimport {mapExecutionLogging} from \"./executionLogModel\";\nimport {mapExecutionResults} from \"./resultsModel\";\nimport {runScenarios} from \"./runScenarios\";\nimport {ComponentNodeList} from \"lexy/dist/language/componentNodeList\";\nimport {IParserLogger} from \"lexy/dist/parser/parserLogger\";\nimport {mapSpecificationsLog} from \"./specificationsLogModel\";\nimport {Dependencies} from \"lexy/dist/dependencyGraph/dependencies\";\nimport {asFunction} from \"lexy/dist/language/functions/function\";\nimport {asScenario, instanceOfScenario} from \"lexy/dist/language/scenarios/scenario\";\nimport {workerOperationStateStorage} from \"../../api/operationStorage\";\n\nexport const operationKey = \"compilation-worker\";\n\nasync function processWorkerRequest(message: MessageEvent<Request>): Promise<void> {\n\n  const {getOperationState} = workerOperationStateStorage();\n\n  async function processStartCompilation(request: StartCompilationRequest) {\n\n    async function parseFiles(request: StartCompilationRequest) {\n\n      const fileSystem = new WebFileSystem(request.folder);\n      const {logging, nodes, logger, elapsed, dependencies} = await parseCode(request.fileName, request.code, fileSystem);\n      const response: CompilationSuccessResponse = {\n        type: ResponseType.CompilationCompleted,\n        error: false,\n        logging: mapLogging(logging),\n        nodes: mapNodes(nodes.values),\n        elapsed: elapsed\n      };\n\n      if (await continueOperation()) {\n        postResponse(response);\n        return {nodes, logger, elapsed, dependencies};\n      } else {\n        return null;\n      }\n    }\n\n    async function continueOperation(): Promise<boolean> {\n      let operationState = await getOperationState(operationKey);\n      let continueValue = operationState === request.timestamp;\n      if (!continueValue) {\n        console.log(`CANCEL CURRENT OPERATION: ${operationState} (new: ${request.timestamp})`);\n      }\n      return continueValue;\n    }\n\n    async function runFileScenarios(fileName: string, nodes: ComponentNodeList, dependencies: Dependencies, logger: IParserLogger) {\n      const result = await runScenarios(fileName, nodes, dependencies, logger, continueOperation);\n      const response: RunScenariosResponse = {\n        type: ResponseType.RunScenariosCompleted,\n        result: mapSpecificationsLog(result),\n      };\n      postResponse(response);\n    }\n\n    try {\n      const result = await parseFiles(request);\n      if (!result) return;\n\n      const {nodes, logger, dependencies} = result;\n      await runFileScenarios(request.fileName, nodes, dependencies, logger);\n    } catch (error: any) {\n      const failed: CompilationFailedResponse = {type: ResponseType.CompilationFailed, error: true, lastError: error.stack};\n      postResponse(failed);\n    }\n  }\n\n  async function processExecuteFunction(request: RunFunctionRequest) {\n    const startTime = new Date();\n    try {\n      const fileSystem = new WebFileSystem(request.folder);\n      const {nodes} = await parseFile(request.fileName, fileSystem);\n      const result = compileNodes(nodes.values);\n\n      const node = nodes.getNode(request.functionName);\n      const functionNode = instanceOfScenario(node) ? asScenario(node)?.functionNode : asFunction(node);\n      const executable = result.getFunction(Assert.notNull(functionNode, \"functionNode\"));\n      const parameters = request.parameters;\n      const results = executable.run(parameters);\n      const elapsed = milliseconds(new Date(), startTime).toNumber();\n\n      const response: RunFunctionSuccessResponse = {\n        type: ResponseType.RunFunctionCompleted,\n        error: false,\n        logging: mapExecutionLogging(results.logging),\n        result: mapExecutionResults(results),\n        elapsed: elapsed\n      };\n\n      postResponse(response);\n\n    } catch (error: any) {\n      const failed: RunFunctionFailedResponse = {type: ResponseType.RunFunctionCompleted, error: true, lastError: error.stack};\n      postResponse(failed);\n    }\n  }\n\n  function postResponse(response: Response) {\n    self.postMessage(response);\n  }\n\n  if (message.data.type === RequestType.StartCompilation) {\n    await processStartCompilation(message.data as StartCompilationRequest);\n  } else if (message.data.type === RequestType.RunFunction) {\n    await processExecuteFunction(message.data as RunFunctionRequest);\n  } else {\n    console.log(\"Invalid compile worker request: \" + JSON.stringify(message.data));\n  }\n}\n\nconst self = globalThis as unknown as DedicatedWorkerGlobalScope;\nself.onmessage = processWorkerRequest;\n","import type {IParserLogger} from \"lexy/dist/parser/parserLogger\";\n\nimport {NodeType} from \"lexy/dist/language/nodeType\";\nimport {ScenarioRunner} from \"lexy/dist/specifications/scenarioRunner\";\nimport {asScenario} from \"lexy/dist/language/scenarios/scenario\";\nimport {createLexyCompiler} from \"../../api/parser\";\nimport {Assert, ILexyCompiler} from \"lexy\";\nimport {SpecificationRunnerContext} from \"lexy/dist/specifications/specificationRunnerContext\";\nimport {SpecificationsLogEntry} from \"lexy/dist/specifications/specificationsLogEntry\";\nimport {ComponentNodeList} from \"lexy/dist/language/componentNodeList\";\nimport {MemoryLogger} from \"../../infrastructure/loggers\";\nimport {Dependencies} from \"lexy/dist/dependencyGraph/dependencies\";\n\nexport async function runScenarios(currentFileName: string, nodes: ComponentNodeList, dependencies: Dependencies,\n                             parserLogger: IParserLogger,\n                             continueCheck: () => Promise<boolean>): Promise<readonly SpecificationsLogEntry[]> {\n\n  function addRunners(lexyCompiler: ILexyCompiler, context: SpecificationRunnerContext, scenarioRunners: Array<ScenarioRunner>) {\n    for (const node of nodes.values) {\n      if (node.nodeType !== NodeType.Scenario) continue;\n      const scenario = Assert.notNull(asScenario(node), \"scenario\");\n      const runner = new ScenarioRunner(currentFileName, lexyCompiler, nodes, scenario, context, parserLogger, dependencies);\n      scenarioRunners.push(runner)\n    }\n  }\n\n  async function runRunners(scenarioRunners: Array<ScenarioRunner>): Promise<void> {\n    for (const scenarioRunner of scenarioRunners) {\n      console.log(\"scenarioRunner: \" + scenarioRunner.scenario.name);\n      if (!await continueCheck()) return;\n      scenarioRunner.run()\n    }\n  }\n\n  try {\n    const lexyCompiler = createLexyCompiler();\n    const logger = new MemoryLogger();\n    const context = new SpecificationRunnerContext(logger)\n    const scenarioRunners: Array<ScenarioRunner> = [];\n\n    addRunners(lexyCompiler, context, scenarioRunners);\n    await runRunners(scenarioRunners);\n    context.logTimeSpent();\n    //console.log(\"scenarioRunner: complete \" + JSON.stringify(context.logEntries, null, 4));\n\n    return context.logEntries;\n  } catch (error: any) {\n    console.log(\"scenarioRunner: error \" + error);\n    const entry = new SpecificationsLogEntry(null, null, true, \"Application error occurred: \" + error.stack);\n    return [entry];\n  }\n}\n","import {useMemo} from \"react\";\nimport {IndexedDBStore, windowIndexedDBStore, workerIndexedDBStore} from \"./indexedDb/indexedDBStore\";\nimport {idbConfig} from \"./idbConfig\";\n\ninterface Operation {\n  id: string,\n  timestamp: string\n}\n\nexport interface OperationStateStorage {\n  getOperationState(key: string): Promise<string | null>;\n  updateOperationState(key: string, timestamp: string): Promise<void>;\n}\n\nfunction operationStorage(filesStore: IndexedDBStore<Operation>): OperationStateStorage {\n\n  const {getByID, update} = filesStore;\n\n  async function getOperationState(key: string): Promise<string | null> {\n    const value = await getByID(key);\n    return value != null ? value.timestamp : null;\n  }\n\n  async function updateOperationState(key: string, timestamp: string): Promise<void> {\n    await update({id: key, timestamp: timestamp}, key);\n  }\n\n  return {\n    getOperationState: getOperationState,\n    updateOperationState: updateOperationState\n  }\n}\n\nexport function useOperationStateStorage(): OperationStateStorage {\n  const store = useMemo(() => {\n    const storeOperationState = windowIndexedDBStore<Operation>(idbConfig, \"operation-state\");\n    return operationStorage(storeOperationState);\n  }, []);\n  return store;\n}\n\nexport function workerOperationStateStorage(): OperationStateStorage {\n  const storeOperationState = workerIndexedDBStore<Operation>(idbConfig, \"operation-state\");\n  return operationStorage(storeOperationState);\n}\n","//adapted from use use-indexeddb (https://github.com/hc-oss/use-indexeddb/commit/f6e5deed3f3c1010c4b314d72b25b5a4f454f07f)\n\nexport interface IndexedDBColumn {\n  name: string;\n  keyPath: string;\n  options?: IDBIndexParameters;\n}\n\nexport interface IndexedDBStoreConfig {\n  name: string;\n  id: IDBObjectStoreParameters;\n  indices: IndexedDBColumn[];\n}\n\nexport interface IndexedDBConfig {\n  databaseName: string;\n  version: number;\n  stores: IndexedDBStoreConfig[];\n}\n\nexport interface IndexedDBStore<T> {\n  getByID(id: string | number): Promise<T>;\n  getOneByKey(keyPath: string, value: string | number): Promise<T | undefined>;\n  getManyByKey(keyPath: string, value: string | number): Promise<T[]>;\n  getAll(): Promise<T[]>;\n  add(value: T, key?: any): Promise<number>;\n  addIfNew(value: T, key?: any): Promise<number | null>;\n  update(value: T, key?: any): Promise<any>;\n  deleteByID(id: any): Promise<any>;\n  deleteAll(): Promise<any>;\n  openCursor(cursorCallback: (e: any) => void, keyRange?: IDBKeyRange): Promise<IDBCursorWithValue | void>;\n}\n\nconst self = globalThis as unknown as DedicatedWorkerGlobalScope;\n\nexport function createIndexedDBStore<T>(factory: IDBFactory, config: IndexedDBConfig, currentStore: string) {\n\n  let transaction = 0;\n\n  function validateStore(db: IDBDatabase, storeName: string) {\n    return db.objectStoreNames.contains(storeName);\n  }\n\n  function validateBeforeTransaction(db: IDBDatabase, storeName: string, reject: Function) {\n    if (!db) {\n      reject(\"Queried before opening connection\");\n      return false;\n    }\n    if (!validateStore(db, storeName)) {\n      reject(`Store ${storeName} not found`);\n      return false;\n    }\n    return true;\n  }\n\n  function createTransaction(\n    db: IDBDatabase,\n    dbMode: IDBTransactionMode,\n    currentStore: string,\n    resolve: ((this: IDBTransaction, ev: Event) => any) | null,\n    reject: ((this: IDBTransaction, ev: Event) => any) | null,\n    abort: ((this: IDBTransaction, ev: Event) => any) | null = null\n  ): IDBTransaction {\n    let tx: IDBTransaction = db.transaction(currentStore, dbMode);\n    tx.onerror = reject;\n    tx.oncomplete = resolve;\n    tx.onabort = abort;\n    return tx;\n  }\n\n  async function getConnection(): Promise<IDBDatabase> {\n    const idbInstance = self ? self.indexedDB : null;\n\n    return new Promise<IDBDatabase>((resolve, reject) => {\n      if (!idbInstance) {\n        return reject(\"IndexedDB is null\");\n      }\n\n      const request: IDBOpenDBRequest = idbInstance.open(config.databaseName, config.version);\n\n      request.onsuccess = () => {\n        resolve(request.result);\n      };\n\n      request.onerror = (e: any) => {\n        reject(e.target.error.name);\n      };\n\n      request.onupgradeneeded = (e: any) => {\n        const db = e.target.result;\n        config.stores.forEach(s => {\n          if (!db.objectStoreNames.contains(s.name)) {\n            const store = db.createObjectStore(s.name, s.id);\n            s.indices.forEach(c => {\n              store.createIndex(c.name, c.keyPath, c.options);\n            });\n          }\n        });\n      };\n    });\n  }\n\n  function getByID(id: string | number) {\n    const thisTransaction = ++transaction;\n    console.log(`getByID: ${id}(${thisTransaction})`)\n    return new Promise<T>((resolve, reject) => {\n      getConnection()\n        .then(db => {\n          if (!validateBeforeTransaction(db, currentStore, reject)) return;\n          let tx = createTransaction(db, \"readonly\", currentStore, (e) => console.log(\"Transaction getByID completed: \" + JSON.stringify(e)), reject, null);\n          let objectStore = tx.objectStore(currentStore);\n          let request = objectStore.get(id);\n          request.onsuccess = (e: any) => {\n            console.log(`getByID: ${id}(${thisTransaction}): `, e.target.result, \"...\");\n            resolve(e.target.result as T);\n          };\n          request.onerror = (e: any) => {\n            console.log(`getByID: ${id}(${thisTransaction}): error `, e.target.result);\n            reject(e.target.result as T);\n          };\n        })\n        .catch(reject);\n    });\n  }\n\n  function getOneByKey(keyPath: string, value: string | number) {\n    return new Promise<T | undefined>((resolve, reject) => {\n      getConnection()\n        .then(db => {\n          if (!validateBeforeTransaction(db, currentStore, reject)) return;\n          let tx = createTransaction(db, \"readonly\", currentStore, (e) => console.log(\"Transaction getOneByKey completed: \" + JSON.stringify(e)), reject);\n          let objectStore = tx.objectStore(currentStore);\n          let index = objectStore.index(keyPath);\n          let request = index.get(value);\n          request.onsuccess = (e: any) => {\n            resolve(e.target.result);\n          };\n        })\n        .catch(reject);\n    });\n  }\n\n  function getManyByKey(keyPath: string, value: string | number) {\n    return new Promise<T[]>((resolve, reject) => {\n      getConnection()\n        .then(db => {\n          if (!validateBeforeTransaction(db, currentStore, reject)) return;\n          let tx = createTransaction(db, \"readonly\", currentStore, (e) => console.log(\"Transaction getManyByKey completed: \" + JSON.stringify(e)), reject);\n          let objectStore = tx.objectStore(currentStore);\n          let index = objectStore.index(keyPath);\n          let request = index.getAll(value);\n          request.onsuccess = (e: any) => {\n            resolve(e.target.result);\n          };\n        })\n        .catch(reject);\n    });\n  }\n\n  function getAll() {\n    return new Promise<T[]>((resolve, reject) => {\n      getConnection()\n        .then(db => {\n          if (!validateBeforeTransaction(db, currentStore, reject)) return;\n          let tx = createTransaction(db, \"readonly\", currentStore, () => console.log(\"getAll.validateBeforeTransaction.resolve\"), reject);\n          let objectStore = tx.objectStore(currentStore);\n          let request = objectStore.getAll();\n          request.onsuccess = (e: any) => {\n            resolve(e.target.result as T[]);\n          };\n        })\n        .catch(reject);\n    });\n  }\n\n  function add(value: T, key?: any) {\n    return new Promise<number>((resolve, reject) => {\n      getConnection()\n        .then(db => {\n          if (!validateBeforeTransaction(db, currentStore, reject)) return;\n          let tx = createTransaction(db, \"readwrite\", currentStore, (e) => console.log(\"Transaction add completed: \" + JSON.stringify(e)), reject);\n          let objectStore = tx.objectStore(currentStore);\n          let request = objectStore.add(value);\n          request.onsuccess = (e: any) => {\n            (tx as any)?.commit?.();\n            resolve(e.target.result);\n          };\n        })\n        .catch(reject);\n    });\n  }\n\n  function addIfNew(value: T, key?: any) {\n    return new Promise<number | null>((resolve, reject) => {\n      getConnection()\n        .then(db => {\n          if (!validateBeforeTransaction(db, currentStore, reject)) return;\n          let tx = createTransaction(db, \"readwrite\", currentStore, (e) => console.log(\"Transaction add completed: \" + JSON.stringify(e)), reject);\n          let objectStore = tx.objectStore(currentStore);\n          let request = objectStore.get(key);\n          request.onsuccess = (e: any) => {\n            if (e.target.result) {\n              tx.abort();\n              return resolve(null);\n            }\n\n            let request = objectStore.add(value);\n            request.onsuccess = (e: any) => {\n              tx.commit();\n              resolve(e.target.result);\n            };\n          };\n        })\n        .catch(reject);\n    });\n  }\n\n  function update(value: T, key?: any) {\n    console.trace();\n    console.log(`Update: ${key}(${++transaction}) - ${JSON.stringify(value)}`)\n    return new Promise<any>((resolve, reject) => {\n      getConnection()\n        .then(db => {\n\n          if (!validateBeforeTransaction(db, currentStore, reject)) return;\n          let tx = createTransaction(db, \"readwrite\", currentStore, (e) => console.log(`Transaction update completed: ${key}(${transaction}) - ${JSON.stringify(e)}`), reject);\n          let objectStore = tx.objectStore(currentStore);\n          let request = objectStore.put(value);\n          request.onsuccess = (e: any) => {\n            tx.commit();\n            resolve(e.target.result);\n          };\n        })\n        .catch(reject);\n    });\n  }\n\n  function deleteByID(id: any) {\n    return new Promise<any>((resolve, reject) => {\n      getConnection()\n        .then(db => {\n          if (!validateBeforeTransaction(db, currentStore, reject)) return;\n          let tx = createTransaction(db, \"readwrite\", currentStore, (e) => console.log(\"Transaction deleteByID completed: \" + JSON.stringify(e)), reject);\n          let objectStore = tx.objectStore(currentStore);\n          let request = objectStore.delete(id);\n          request.onsuccess = (e: any) => {\n            (tx as any)?.commit?.();\n            resolve(e);\n          };\n        })\n        .catch(reject);\n    });\n  }\n\n  function deleteAll() {\n    return new Promise<any>((resolve, reject) => {\n      getConnection()\n        .then(db => {\n          if (!validateBeforeTransaction(db, currentStore, reject)) return;\n          let tx = createTransaction(db, \"readwrite\", currentStore, (e) => console.log(\"Transaction deleteAll completed: \" + JSON.stringify(e)), reject);\n          let objectStore = tx.objectStore(currentStore);\n          let request = objectStore.clear();\n          request.onsuccess = (e: any) => {\n            (tx as any)?.commit?.();\n            resolve(e);\n          };\n        })\n        .catch(reject);\n    });\n  }\n\n  function openCursor(cursorCallback: (e: any) => void, keyRange?: IDBKeyRange) {\n    return new Promise<IDBCursorWithValue | void>((resolve, reject) => {\n      getConnection()\n        .then(db => {\n          if (!validateBeforeTransaction(db, currentStore, reject)) return;\n          let tx = createTransaction(db, \"readonly\", config.databaseName, (e) => console.log(\"Transaction openCursor completed: \" + JSON.stringify(e)), reject);\n          let objectStore = tx.objectStore(config.databaseName);\n          let request = objectStore.openCursor(keyRange);\n          request.onsuccess = e => {\n            cursorCallback(e);\n            resolve();\n          };\n        })\n        .catch(reject);\n    });\n  }\n\n  return {\n    add: add,\n    addIfNew: addIfNew,\n    update: update,\n    deleteByID: deleteByID,\n    deleteAll: deleteAll,\n    openCursor: openCursor,\n    getByID: getByID,\n    getAll: getAll,\n    getManyByKey: getManyByKey,\n    getOneByKey: getOneByKey,\n  };\n}\n\nexport function workerIndexedDBStore<T>(config: IndexedDBConfig, storeName: string): IndexedDBStore<T> {\n  return createIndexedDBStore<T>(self.indexedDB, config, storeName);\n}\n\nexport function windowIndexedDBStore<T>(config: IndexedDBConfig, storeName: string): IndexedDBStore<T> {\n  return createIndexedDBStore<T>(window.indexedDB, config, storeName);\n}\n","export const idbConfig = {\n  databaseName: \"lexy\",\n  version: 2,\n  stores: [\n    {\n      name: \"operation-state\",\n      id: { keyPath: \"id\", autoIncrement: false },\n      indices: []\n    },\n    {\n      name: \"code-files\",\n      id: { keyPath: \"id\", autoIncrement: true },\n      indices: []\n    }\n  ]\n};\n","import type {INode} from \"lexy/dist/language/node\";\n\nimport {Function} from \"lexy/dist/language/functions/function\";\nimport {NodeType} from \"lexy/dist/language/nodeType\";\nimport {asComponentNode} from \"lexy/dist/language/componentNode\";\nimport {Assert} from \"lexy\";\nimport {asVariableDefinition} from \"lexy/dist/language/variableDefinition\";\nimport {asVariableDeclarationExpression} from \"lexy/dist/language/expressions/variableDeclarationExpression\";\nimport {asAssignmentDefinition} from \"lexy/dist/language/scenarios/assignmentDefinition\";\nimport {asColumnHeader} from \"lexy/dist/language/tables/columnHeader\";\nimport {nothing, Nothing} from \"../../infrastructure/nothing\";\nimport {asEnumMember} from \"lexy/dist/language/enums/enumMember\";\nimport {Type} from \"lexy/dist/language/typeSystem/type\";\nimport {TypeKind} from \"lexy/dist/language/typeSystem/typeKind\";\nimport {asValueType} from \"lexy/dist/language/typeSystem/valueType\";\nimport {asObjectType} from \"lexy/dist/language/typeSystem/objects/objectType\";\nimport {TypeNames} from \"lexy/dist/language/typeSystem/typeNames\";\n\nexport enum NodeKind {\n  Unknown = \"Unknown\",\n  Function = \"Function\",\n  Scenario = \"Scenario\",\n  Table = \"Table\",\n  Type = \"Type\",\n  Enum = \"Enum\",\n\n  Code = \"Code\",\n  Results = \"Results\",\n  Parameters = \"Parameters\",\n  EnumMember = \"EnumMember\",\n  Errors = \"Errors\",\n  Number = \"Number\",\n  Boolean = \"Boolean\",\n  Date = \"Date\",\n  String = \"String\",\n\n  Expression = \"Expression\",\n}\n\nexport interface NodeModel {\n  readonly name: string;\n  readonly kind: NodeKind;\n  readonly fileName: string;\n  readonly lineNumber: number;\n  readonly characterNumber: number;\n  readonly children: readonly NodeModel[];\n  readonly nodeType: NodeType;\n}\n\nexport interface FunctionNodeModel extends NodeModel {\n  readonly kind: NodeKind.Function;\n  readonly parameters: readonly VariableModel[];\n}\n\nexport enum TypeModelKind {\n  Unsupported,\n  Primitive,\n  Enum,\n  Object,\n}\n\nexport interface TypeModel {\n  readonly kind: TypeModelKind;\n  readonly name: string;\n}\n\nexport interface EnumTypeModel extends TypeModel {\n  readonly kind: TypeModelKind.Enum;\n  readonly members: string[]\n}\n\nexport interface ObjectTypeModel extends TypeModel {\n  readonly kind: TypeModelKind.Object;\n  readonly variables: VariableModel[];\n}\n\nexport interface VariableModel {\n  readonly name: string;\n  readonly type: TypeModel;\n}\n\nexport function mapNodes(nodes: readonly INode[]): NodeModel[] {\n\n  const typesCache: {[key: string]: TypeModel} = {};\n\n  function mapTypeToKind(variableType: Type | Nothing | undefined): NodeKind  {\n\n    function mapValueType() {\n      const valueType = asValueType(variableType);\n      switch (valueType?.type) {\n        case TypeNames.number:\n          return NodeKind.Number;\n        case TypeNames.boolean:\n          return NodeKind.Boolean;\n        case TypeNames.date:\n          return NodeKind.Date;\n        case TypeNames.string:\n          return NodeKind.String;\n        default:\n          return NodeKind.Unknown;\n      }\n    }\n\n    switch (variableType?.typeKind) {\n      case TypeKind.TableType:\n        return NodeKind.Table;\n      case TypeKind.EnumType:\n        return NodeKind.Enum;\n      case TypeKind.DeclaredType:\n        return NodeKind.Type;\n      case TypeKind.GeneratedType:\n        return NodeKind.Type;\n      case TypeKind.ValueType:\n        return mapValueType();\n      case TypeKind.FunctionType:\n        return NodeKind.Function;\n\n      case TypeKind.VoidType:\n      case nothing:\n      default:\n        return NodeKind.Unknown;\n    }\n  }\n\n  function mapType(type: Type | Nothing): TypeModel {\n\n    function mapValueType(): TypeModel {\n      let valueType = Assert.notNull(asValueType(type), \"asValueType\");\n      return {\n        kind: TypeModelKind.Primitive,\n        name: valueType.type\n      };\n    }\n\n    function fromCache<T extends TypeModel>(name: string, factory: () => T): T {\n      if (typesCache[name]) return typesCache[name] as T;\n      const type = factory();\n      typesCache[name] = type;\n      return type;\n    }\n\n    function mapObjectType () {\n      let objectType = Assert.notNull(asObjectType(type), \"asGeneratedType\");\n      return fromCache<ObjectTypeModel>(objectType.name, () => ({\n        kind: TypeModelKind.Object,\n        name: objectType.name,\n        variables: objectType.members.map(member => ({name: member.name, type: mapType(member.type)}))\n      }));\n    }\n\n    switch (type?.typeKind) {\n      case TypeKind.ValueType:\n        return mapValueType();\n      case TypeKind.GeneratedType:\n        return mapObjectType();\n      case TypeKind.DeclaredType:\n        return mapObjectType();\n      case TypeKind.EnumType:\n        return mapObjectType();\n\n      case TypeKind.FunctionType:\n      case TypeKind.TableType:\n      default:\n        return {kind: TypeModelKind.Unsupported, name: type?.typeKind ?? \"nothing\"}\n    }\n  }\n\n  function mapParameters(functionNode: Function): readonly VariableModel[] {\n    return functionNode.parameters.variables.map(variabel => ({\n      name: variabel.name,\n      type: mapType(variabel.type),\n    }));\n  }\n\n  function mapFunction(node: INode): FunctionNodeModel {\n    const functionNode = createNode(node, NodeKind.Function);\n    const parameters = mapParameters(node as Function);\n    return {...functionNode, kind: NodeKind.Function, parameters: parameters};\n  }\n\n  function createNode(node: INode, kind: NodeKind, name: string | Nothing = nothing,  mapChildren: boolean = true): NodeModel {\n\n    const componentNode = asComponentNode(node);\n    const componentNodeName = componentNode ? componentNode.name : \"\";\n\n    const children = mapChildren ? mapNodes(node.getChildren()) : [];\n\n    return {\n      name: name ?? componentNodeName,\n      kind: kind,\n      children: children,\n      fileName: node.reference.file.fileName,\n      lineNumber: node.reference.lineNumber,\n      characterNumber: node.reference.characterNumber,\n      nodeType: node.nodeType\n    }\n  }\n\n  function mapVariableDefinition(node: INode) {\n    const definition = Assert.notNull(asVariableDefinition(node), \"variableDefinition\");\n    const functionNode = createNode(node, NodeKind.Function, definition.name);\n    return {...functionNode, kind: NodeKind.Function, type: mapType(definition.type)};\n  }\n\n  function mapNode(node: INode): NodeModel | Nothing {\n\n    switch (node.nodeType) {\n      case NodeType.FunctionName:\n      case NodeType.ScenarioName:\n      case NodeType.ScenarioFunctionName:\n      case NodeType.EnumName:\n      case NodeType.TableRow:\n        return null;\n\n      case NodeType.Function:\n        return mapFunction(node);\n      case NodeType.Scenario:\n        return createNode(node, NodeKind.Scenario);\n      case NodeType.Table:\n        return createNode(node, NodeKind.Table);\n      case NodeType.TypeDefinition:\n        return createNode(node, NodeKind.Type);\n      case NodeType.EnumDefinition:\n        return createNode(node, NodeKind.Enum);\n\n      case NodeType.FunctionResults:\n      case NodeType.ScenarioResults:\n        return createNode(node, NodeKind.Results, \"Results\");\n\n      case NodeType.FunctionParameters:\n      case NodeType.ScenarioParameters:\n        return createNode(node, NodeKind.Parameters, \"Parameters\");\n      case NodeType.FunctionCode:\n        return createNode(node, NodeKind.Code, \"Code\");\n      case NodeType.VariableDefinition: {\n        return mapVariableDefinition(node);\n      }\n      case NodeType.VariableDeclarationExpression: {\n        let expression = Assert.notNull(asVariableDeclarationExpression(node), \"variableDeclarationExpression\");\n        return createNode(node, mapTypeToKind(expression.typeDeclaration.type), nothing, false);\n      }\n      case NodeType.AssignmentDefinition: {\n        let definition = Assert.notNull(asAssignmentDefinition(node), \"variableDefinition\");\n        return createNode(node, mapTypeToKind(definition.type), definition.variable.path.join(\".\"), false);\n      }\n\n      case NodeType.EnumMember: {\n        let enumMember = Assert.notNull(asEnumMember(node), \"enumMember\");\n        return createNode(node, NodeKind.EnumMember, enumMember.name, false);\n      }\n\n      case NodeType.ScenarioExpectErrors:\n        return createNode(node, NodeKind.Errors, \"Expect Errors\", true);\n      case NodeType.ScenarioExpectComponentErrors:\n        return createNode(node, NodeKind.Errors, \"Expect Component Error\", true);\n\n      case NodeType.TableHeader:\n        return createNode(node, NodeKind.Table, \"Header\", true);\n\n      case NodeType.ColumnHeader: {\n        const column = Assert.notNull(asColumnHeader(node), \"columnHeader\");\n        return createNode(node, mapTypeToKind(column.typeDeclaration?.type), column.name, false);\n      }\n\n      default: {\n        if (node.nodeType.endsWith(\"Expression\")) {\n          return createNode(node, NodeKind.Expression, node.nodeType, true);\n        }\n        return createNode(node, NodeKind.Unknown, node.nodeType, true);\n      }\n    }\n  }\n\n  function mapNodeValues(children: readonly INode[]) {\n    const result = new Array<NodeModel>();\n    for (const node of children) {\n      const nodeModel = mapNode(node);\n      if (nodeModel !== null) {\n        result.push(nodeModel);\n      }\n    }\n    return result;\n  }\n\n  return mapNodeValues(nodes);\n}\n","export const nothing = null;\n\nexport type Nothing = null;\n","import {NodeModel} from \"../project/nodeModel\";\nimport {LogModel} from \"../project/logModel\";\nimport {ResultsModel} from \"./resultsModel\";\nimport {ExecutionLogModel} from \"./executionLogModel\";\nimport {SpecificationsLogModel} from \"./specificationsLogModel\";\n\nexport enum ResponseType {\n  CompilationCompleted,\n  CompilationFailed,\n  RunFunctionCompleted,\n  RunScenariosCompleted\n}\n\nexport type CompilationSuccessResponse = {\n  readonly type: ResponseType.CompilationCompleted;\n  readonly error: false;\n  readonly logging: readonly LogModel[];\n  readonly nodes: readonly NodeModel[];\n  readonly elapsed: number;\n}\n\nexport type CompilationFailedResponse = {\n  readonly type: ResponseType.CompilationFailed;\n  readonly error: true;\n  readonly lastError: string;\n}\n\nexport type RunScenariosResponse = {\n  readonly type: ResponseType.RunScenariosCompleted;\n  readonly result: readonly SpecificationsLogModel[],\n};\n\nexport type RunFunctionSuccessResponse = {\n  readonly type: ResponseType.RunFunctionCompleted;\n  readonly error: false;\n  readonly logging: readonly ExecutionLogModel[];\n  readonly result: ResultsModel;\n  readonly elapsed: number;\n}\n\nexport type RunFunctionFailedResponse = {\n  readonly type: ResponseType.RunFunctionCompleted;\n  readonly error: true;\n  readonly lastError: string;\n}\n\nexport type CompilationCompletedResponse = CompilationSuccessResponse | CompilationFailedResponse;\nexport type RunFunctionCompletedResponse = RunFunctionSuccessResponse | RunFunctionFailedResponse;\n\nexport type Response = CompilationCompletedResponse | RunScenariosResponse | RunFunctionCompletedResponse;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [4926], () => (__webpack_require__(35106)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and chunks that the entrypoint depends on\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"0b465a07\" + \".chunk.js\";\n};","// This function allow to reference async chunks and chunks that the entrypoint depends on\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"https://lexy-language.github.io/lexy-editor/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t5106: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunklexy_editor\"] = self[\"webpackChunklexy_editor\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(4926).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["RequestType","codeFileStorage","filesStore","getByID","addIfNew","update","deleteAll","getCodeFile","identifier","Promise","resolve","reject","then","value","code","catch","storeCodeFile","override","id","_","clearCodeFiles","workerCodeFileStorage","workerIndexedDBStore","idbConfig","WebFileSystem","constructor","currentFolder","store","this","readAllLines","fileName","parts","isPathRooted","getFullPath","split","removeFirst","data","join","Error","getFileName","fullFileName","getDirectoryName","parentFullFileName","removeLast","length","folder","part","push","splice","combine","fullPath","fileParts","fileExists","directoryExists","absoluteFolder","startsWith","getDirectoryFiles","extension","getDirectories","logFolders","MemoryLogger","loggingValue","logging","isEnabled","level","logDebug","message","LogLevel","Debug","logError","logInformation","Information","baseLogger","async","parseCode","fileSystem","lines","startTime","Date","lexyParser","createParser","Libraries","componentNodes","logger","dependencies","parse","suppressException","elapsed","milliseconds","toNumber","entries","nodes","parseLines","createLexyCompiler","createCompiler","mapLogging","map","mapLogEntry","entry","reference","file","lineNumber","characterNumber","sortIndex","isError","end","start","laterDate","earlierDate","Decimal","mapExecutionLog","readVariables","writeVariables","mapExecutionLogging","mapExecutionResults","results","mapSpecificationsLogModel","result","_result$reference","nodeName","node","name","nothing","errors","executionLogging","mapSpecificationsLog","self","globalThis","onmessage","getOperationState","workerOperationStateStorage","postResponse","response","postMessage","type","StartCompilation","request","continueOperation","operationState","continueValue","timestamp","console","log","concat","ResponseType","CompilationCompleted","error","mapNodes","values","parseFiles","currentFileName","parserLogger","continueCheck","lexyCompiler","context","SpecificationRunnerContext","scenarioRunners","nodeType","NodeType","Scenario","scenario","Assert","notNull","asScenario","runner","ScenarioRunner","addRunners","scenarioRunner","run","runRunners","logTimeSpent","logEntries","SpecificationsLogEntry","stack","runScenarios","RunScenariosCompleted","runFileScenarios","CompilationFailed","lastError","processStartCompilation","RunFunction","_asScenario","parseFile","compile","compileNodes","getNode","functionName","functionNode","instanceOfScenario","asFunction","executable","getFunction","parameters","RunFunctionCompleted","processExecuteFunction","JSON","stringify","operationStorage","key","updateOperationState","createIndexedDBStore","factory","config","currentStore","transaction","validateBeforeTransaction","db","storeName","objectStoreNames","contains","validateStore","createTransaction","dbMode","abort","arguments","undefined","tx","onerror","oncomplete","onabort","getConnection","idbInstance","indexedDB","open","databaseName","version","onsuccess","e","target","onupgradeneeded","stores","forEach","s","createObjectStore","indices","c","createIndex","keyPath","options","add","objectStore","_commit","_ref","commit","call","get","trace","put","deleteByID","delete","_commit2","_ref2","clear","_commit3","_ref3","openCursor","cursorCallback","keyRange","thisTransaction","getAll","getManyByKey","index","getOneByKey","autoIncrement","NodeKind","TypeModelKind","typesCache","mapTypeToKind","variableType","typeKind","TypeKind","TableType","Table","EnumType","Enum","DeclaredType","GeneratedType","Type","ValueType","valueType","asValueType","TypeNames","number","Number","boolean","Boolean","date","string","String","Unknown","mapValueType","FunctionType","Function","VoidType","mapType","_type$typeKind","mapObjectType","objectType","asObjectType","fromCache","kind","Object","variables","members","member","Primitive","Unsupported","mapFunction","createNode","variabel","mapParameters","_objectSpread","mapChildren","componentNode","asComponentNode","componentNodeName","children","getChildren","mapNode","FunctionName","ScenarioName","ScenarioFunctionName","EnumName","TableRow","TypeDefinition","EnumDefinition","FunctionResults","ScenarioResults","Results","FunctionParameters","ScenarioParameters","Parameters","FunctionCode","Code","VariableDefinition","definition","asVariableDefinition","mapVariableDefinition","VariableDeclarationExpression","asVariableDeclarationExpression","typeDeclaration","AssignmentDefinition","asAssignmentDefinition","variable","path","EnumMember","enumMember","asEnumMember","ScenarioExpectErrors","Errors","ScenarioExpectComponentErrors","TableHeader","ColumnHeader","_column$typeDeclarati","column","asColumnHeader","endsWith","Expression","Array","nodeModel","mapNodeValues","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","x","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","i","fulfilled","j","keys","every","r","n","getter","__esModule","d","a","o","defineProperty","enumerable","f","chunkId","all","reduce","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next"],"ignoreList":[],"sourceRoot":""}